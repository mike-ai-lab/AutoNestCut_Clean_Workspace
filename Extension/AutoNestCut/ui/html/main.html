<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <title>AutoNestCut - Build 20250119_1445</title>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700;800;900&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="style.css">
    <link rel="stylesheet" href="diagrams_style.css">
    <link rel="stylesheet" href="resizer_fix.css">
    <style>
        /* Additional styles for new design */
        .section {
            background: #ffffff;
            border: 1px solid #d0d7de;
            border-radius: 6px;
            margin-bottom: 40px;
        }
        .section-header {
            padding: 14px 18px;
            background: #f6f8fa;
            border-bottom: 1px solid #d0d7de;
            display: flex;
            justify-content: space-between;
            align-items: center;
            cursor: pointer;
        }
        .section-header:hover { background: #f1f5f9; }
        .section-title { font-size: 15px; font-weight: 600; color: #24292e; }
        .section-toggle { font-size: 13px; color: #656d76; }
        .section-content { 
            padding: 20px; 
            overflow: hidden;
            max-height: 1000px;
            transition: max-height 0.3s ease-out, padding 0.3s ease-out;
        }
        .section.collapsed .section-content { 
            max-height: 0;
            padding-top: 0;
            padding-bottom: 0;
        }
        .section.collapsed .section-toggle::before { content: '▶'; }
        .section-toggle::before { content: '▼'; }
        
        /* Parts Preview - Horizontal Layout */
        .parts-preview-wrapper {
            display: flex;
            gap: 20px;
            margin-bottom: 40px;
        }
        
        /* Table Container */
        .parts-table-container {
            flex: 1;
            background: #ffffff;
            border: 1px solid #d0d7de;
            border-radius: 6px;
            overflow: hidden;
        }
        .parts-table-header {
            padding: 16px 20px;
            background: #2323FF;
            color: #ffffff;
            font-size: 16px;
            font-weight: 600;
        }
        .parts-table-scroll {
            overflow-y: auto;
            max-height: 600px;
        }
        
        /* Canvas Container */
        .parts-canvas-container {
            flex: 1;
            background: #ffffff;
            border: 1px solid #d0d7de;
            border-radius: 6px;
            display: flex;
            flex-direction: column;
            overflow: hidden;
        }
        .canvas-header {
            padding: 16px 20px;
            background: #2323FF;
            color: #ffffff;
            font-size: 16px;
            font-weight: 600;
        }
        
        .channel-button {
            position: relative;
            display: inline-block;
        }
        .channel-button a {
            color: white;
            font-family: 'Inter', sans-serif;
            font-weight: bold;
            font-size: 14px;
            text-align: center;
            text-decoration: none;
            background-color: #1a8cff;
            display: block;
            position: relative;
            padding: 8px 16px;
            text-shadow: 0px 1px 0px #000;
            box-shadow: inset 0 1px 0 #5eb3ff, 0 4px 0 #0d5299;
            border-radius: 5px;
            transition: all 0.1s;
        }
        .channel-button a:active {
            top: 4px;
            background-color: #1570cc;
            box-shadow: inset 0 1px 0 #5eb3ff, inset 0 -2px 0 #0d5299;
        }
        .channel-button:after {
            content: "";
            height: 100%;
            width: 100%;
            padding: 2px;
            position: absolute;
            bottom: -6px;
            left: -2px;
            z-index: -1;
            background-color: #0a2d5c;
            border-radius: 5px;
        }
        .canvas-viewport {
            flex: 1;
            display: flex;
            align-items: center;
            justify-content: center;
            background: #fafbfc;
            position: relative;
            min-height: 500px;
        }
        #parts3DCanvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            cursor: grab;
            display: none;
        }
        #parts3DCanvas:active { cursor: grabbing; }
        #canvasPlaceholder {
            text-align: center;
            color: #656d76;
            padding: 40px;
            max-width: 300px;
        }
        #canvasPlaceholder p {
            font-size: 14px;
            line-height: 1.8;
            margin: 0;
        }
        .canvas-info {
            padding: 16px 20px;
            background: #f6f8fa;
            border-top: 1px solid #d0d7de;
            font-size: 12px;
            color: #656d76;
        }
        .canvas-info-row {
            display: flex;
            justify-content: space-between;
            margin: 6px 0;
        }
        .canvas-info-label { font-weight: 500; }

        /* Exploded View Slider */
        .explode-controls {
            position: absolute;
            right: 60px; /* Positioned to the left of the view controls */
            top: 50%;
            transform: translateY(-50%);
            height: 60%;
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 10px;
            z-index: 100;
            background: rgba(255, 255, 255, 0.9);
            padding: 15px 8px;
            border-radius: 30px;
            box-shadow: 0 4px 12px rgba(0,0,0,0.15);
            border: 1px solid #d0d7de;
            transition: opacity 0.3s;
        }

        .explode-label {
            writing-mode: vertical-rl;
            text-orientation: mixed;
            font-size: 11px;
            font-weight: 700;
            color: #4a4a4a;
            letter-spacing: 1px;
            margin-bottom: 5px;
            user-select: none;
        }

        .explode-slider {
            writing-mode: vertical-lr;
            direction: rtl;
            width: 6px;
            height: 100%;
            outline: none;
            cursor: ns-resize;
        }

        .currency-conversion {
            display: flex;
            flex-direction: column;
            gap: 10px;
            padding: 10px;
            border: 1px solid #ddd;
            border-radius: 5px;
            background: #f9f9f9;
        }
        .currency-conversion label {
            font-weight: bold;
            margin-bottom: 5px;
        }
        .currency-conversion select,
        .currency-conversion input {
            padding: 5px;
            border: 1px solid #ccc;
            border-radius: 3px;
        }
        .currency-conversion button {
            margin-top: 10px;
            padding: 8px 16px;
            background: #007cba;
            color: white;
            border: none;
            border-radius: 3px;
            cursor: pointer;
        }
        .currency-conversion button:hover {
            background: #005a87;
        }
        
        /* Summary Cards Hover Effects */
        .glass-card {
            transition: all 0.3s ease;
        }
        .glass-card:hover {
            transform: translateY(-4px);
            box-shadow: 0 8px 24px rgba(0,0,0,0.15) !important;
        }

        /* Icon button specific styling, ensure it's clean and consistent */
        .icon-btn, .material-icon-btn {
            padding: 5px; /* Adjust padding as needed for icon size */
            background: #ffffff; /* Default background */
            color: #24292e; /* Default icon color */
            border: 1px solid #d0d7de; /* Default border */
            border-radius: 4px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.15s;
        }
        .icon-btn:hover, .material-icon-btn:hover {
            background: #f6f8fa;
            border-color: #8c959f;
        }
        /* Override for header action buttons for primary blue look */
        .header-controls .action-buttons .tab-button.icon-btn {
            background: #007cba;
            color: white;
            border: none; /* No border for these primary action icons */
        }
        .header-controls .action-buttons .tab-button.icon-btn:hover {
            background: #005a87;
            border-color: transparent;
        }
        .icon-btn svg, .material-icon-btn svg {
            stroke: currentColor; /* Ensure SVG uses button's text color */
            stroke-width: 2;
            width: 16px;
            height: 16px;
        }
        #settingsModal {
            z-index: 1000;
        }
        #settingsModal .modal-content {
            z-index: 1001;
        }
        
        /* Fullscreen Overlay Styles */
        .fullscreen-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.95);
            z-index: 10000;
            display: none;
            animation: fadeIn 0.3s ease;
        }
        
        .fullscreen-overlay.active {
            display: flex;
            flex-direction: column;
        }
        
        @keyframes fadeIn {
            from { opacity: 0; }
            to { opacity: 1; }
        }
        
        .fullscreen-header {
            background: #2323FF;
            color: white;
            padding: 16px 24px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            box-shadow: 0 2px 8px rgba(0,0,0,0.3);
        }
        
        .fullscreen-title {
            font-size: 18px;
            font-weight: 600;
        }
        
        .fullscreen-close-btn {
            background: rgba(255,255,255,0.2);
            border: 1px solid rgba(255,255,255,0.4);
            color: white;
            width: 40px;
            height: 40px;
            border-radius: 6px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.2s;
        }
        
        .fullscreen-close-btn:hover {
            background: rgba(255,255,255,0.3);
            transform: scale(1.05);
        }
        
        .fullscreen-content {
            flex: 1;
            overflow: auto;
            padding: 20px;
        }
        
        .fullscreen-table-wrapper {
            background: white;
            border-radius: 8px;
            overflow: hidden;
            height: 100%;
        }
        
        .fullscreen-table-wrapper table {
            width: 100%;
            font-size: 14px;
        }
        
        .fullscreen-canvas-wrapper {
            background: #1a1a1a;
            border-radius: 8px;
            height: 100%;
            position: relative;
            display: flex;
            flex-direction: column;
        }
        
        .maximize-btn:hover {
            background: rgba(255,255,255,0.3) !important;
            transform: scale(1.05);
        }
        
        /* Combined fullscreen view */
        .fullscreen-combined-wrapper {
            display: flex;
            gap: 20px;
            height: 100%;
            padding: 0;
        }
        
        .fullscreen-combined-wrapper .parts-table-container,
        .fullscreen-combined-wrapper .parts-canvas-container {
            flex: 1;
            background: white;
            border-radius: 8px;
            overflow: hidden;
        }
        
        .fullscreen-combined-wrapper .parts-canvas-container {
            background: #1a1a1a;
        }
    </style>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/html2canvas@1.4.1/dist/html2canvas.min.js"></script>
    <script src="languages.js"></script>
</head>
<body>
    <div class="header">
        <div class="header-content">
            <h1 data-translate="app_title">AutoNestCut</h1>
            <p class="developer-credit" data-translate="developer_credit">by Int. Arch. M.Shkeir</p>
        </div>
        <div class="header-controls">
            <!-- Settings Button - Always visible -->
            <button class="settings-btn icon-btn" onclick="openSettings()" title="Settings">
                <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                    <circle cx="12" cy="12" r="3"/>
                    <path d="M12 1v6m0 6v6m11-7h-6m-6 0H1m21-7h-6M7 5H1m21 7h-6M7 19H1"/>
                </svg>
            </button>
            <div class="action-buttons">
                <!-- Configuration Tab Buttons -->
                <button class="tab-button" id="generateCutListButton" onclick="processNesting()" data-translate="generate_cut_list">Generate Cut List</button>
                <button class="tab-button" id="refreshSelectionButton" onclick="refreshConfiguration()" data-translate="refresh_selection">Refresh Selection</button>
                <button class="tab-button" id="cancelButton" onclick="window.close()" data-translate="cancel">Cancel</button>

                <!-- Report Tab Buttons - Hidden by default -->
                <button class="tab-button icon-btn report-action-btn" id="refreshReportButton" onclick="refreshReportWithFeedback()" data-translate="refresh_report" style="display: none;" title="Refresh Report">
                    <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                        <path d="M3 12a9 9 0 0 1 9-9 9.75 9.75 0 0 1 6.74 2.74L21 8"/>
                        <path d="M21 3v5h-5"/>
                        <path d="M21 12a9 9 0 0 1-9 9 9.75 9.75 0 0 1-6.74-2.74L3 16"/>
                        <path d="M3 21v-5h5"/>
                    </svg>
                </button>
                                <button class="tab-button icon-btn report-action-btn" id="exportCsvButton" data-translate="export_csv_report" style="display: none;" title="Export CSV Report">
                    <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                        <path d="M14.5 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V7.5L14.5 2z"/>
                        <polyline points="14,2 14,8 20,8"/>
                        <line x1="16" y1="13" x2="8" y2="13"/>
                        <line x1="16" y1="17" x2="8" y2="17"/>
                        <line x1="10" y1="9" x2="8" y2="9"/>
                    </svg>
                </button>
                <button class="tab-button icon-btn report-action-btn" id="exportPdfButton" data-translate="export_pdf_report" style="display: none;" title="Export PDF Report">
                    <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                        <path d="M14 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V8z"/>
                        <polyline points="14 2 14 8 20 8"/>
                        <text x="9" y="17" font-size="6" font-weight="bold">PDF</text>
                    </svg>
                </button>
                <button class="tab-button icon-btn report-action-btn" id="exportHtmlButton" data-translate="export_interactive_html" style="display: none;" title="Export Interactive HTML">
                    <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                        <polyline points="16 18 22 12 16 6"/>
                        <polyline points="8 6 2 12 8 18"/>
                    </svg>
                </button>
                <button class="tab-button icon-btn report-action-btn" id="copyMarkdownButton" data-translate="copy_markdown_report" style="display: none;" title="Copy Markdown Report">
                    <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                        <rect width="14" height="14" x="8" y="8" rx="2" ry="2"/>
                        <path d="M4 16c-1.1 0-2-.9-2-2V4c0-1.1.9-2 2-2h10c1.1 0 2 .9 2 2"/>
                    </svg>
                </button>
                <button class="tab-button icon-btn report-action-btn" id="exportDrawingsButton" onclick="exportTechnicalDrawings()" style="display: none;" title="Export Technical Drawings">
                    <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                        <path d="M21 15a2 2 0 0 1-2 2H7l-4 4V5a2 2 0 0 1 2-2h14a2 2 0 0 1 2 2z"/>
                        <circle cx="9" cy="10" r="1"/>
                        <circle cx="12" cy="10" r="1"/>
                        <circle cx="15" cy="10" r="1"/>
                    </svg>
                </button>
            </div>
            <div class="tabs">
                <button class="tab-button active" onclick="showTab('config')" data-translate="configuration">Configuration</button>
                <button class="tab-button" id="reportTab" onclick="showTab('report')" disabled data-translate="report">Report</button>
                <button class="tab-button" id="dashboardTab" onclick="showTab('dashboard')" disabled data-translate="dashboard">Dashboard</button>
            </div>
        </div>
    </div>

    <!-- Configuration Tab -->
    <div id="configTab" class="tab-content active">
        <div class="config-container">
            
            <!-- Project Configuration -->
            <div class="section collapsed">
                <div class="section-header" onclick="toggleSection(this)">
                    <span class="section-title">Project Configuration</span>
                    <span class="section-toggle"></span>
                </div>
                <div class="section-content">
                    <div class="form-row">
                        <div class="form-group">
                            <label>Project Name</label>
                            <input type="text" id="project_name" placeholder="Enter project name">
                        </div>
                        <div class="form-group">
                            <label>Client Name</label>
                            <input type="text" id="client_name" placeholder="Enter client name">
                        </div>
                        <div class="form-group">
                            <label>Prepared By</label>
                            <input type="text" id="prepared_by" value="Int. Arch. M.Shkeir">
                        </div>
                        <div class="form-group">
                            <label>Kerf Width (mm)</label>
                            <input type="number" id="kerf_width" value="3.0" step="0.1">
                        </div>
                    </div>
                    <div class="form-group" style="margin-top: 10px;">
                        <label style="display: flex; align-items: center; gap: 8px; cursor: pointer;">
                            <input type="checkbox" id="allow_rotation" checked>
                            <span style="font-size: 14px; color: #24292e;">Allow part rotation</span>
                        </label>
                    </div>
                </div>
            </div>
            
            <!-- Selection Status -->
            <div class="section collapsed">
                <div class="section-header" onclick="toggleSection(this)">
                    <span class="section-title">Selection Status</span>
                    <span class="section-toggle"></span>
                </div>
                <div class="section-content">
                    <div id="selectionStatusTree" style="background: #f8fafc; border: 1px solid #d0d7de; border-radius: 5px; padding: 16px; max-height: 300px; overflow-y: auto; font-size: 13px;">
                        <p style="color: #656d76;">No selection detected. Please select components in SketchUp.</p>
                    </div>
                </div>
            </div>
            
            <!-- Components Found -->
            <div class="section collapsed">
                <div class="section-header" onclick="toggleSection(this)">
                    <span class="section-title">Components Found (<span id="totalComponentsCount">0</span>)</span>
                    <span class="section-toggle"></span>
                </div>
                <div class="section-content">
                    <div style="overflow-y: auto; max-height: 400px;">
                        <table>
                            <thead>
                                <tr>
                                    <th>Component</th>
                                    <th>Width (mm)</th>
                                    <th>Height (mm)</th>
                                    <th>Thickness (mm)</th>
                                    <th>Material</th>
                                </tr>
                            </thead>
                            <tbody id="componentsTableBody">
                                <tr>
                                    <td colspan="5" style="text-align: center; color: #656d76; padding: 20px;">No components found</td>
                                </tr>
                            </tbody>
                        </table>
                    </div>
                </div>
            </div>
            
            <!-- TWO COLUMN LAYOUT: Parts Preview & Stock Materials -->
            <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 20px; margin-bottom: 40px;">
                
                <!-- LEFT COLUMN: PARTS PREVIEW -->
                <div class="section">
                    <div class="section-header" onclick="toggleSection(this)">
                        <span class="section-title">Parts Preview</span>
                        <span class="section-toggle"></span>
                    </div>
                    <div class="section-content" style="padding: 0;">
                        <div style="overflow-y: auto; overflow-x: auto; max-height: 600px;">
                            <table class="google-sheets-table">
                                <thead>
                                    <tr>
                                        <th>Component Name</th>
                                        <th>Width (mm)</th>
                                        <th>Height (mm)</th>
                                        <th>Thickness (mm)</th>
                                        <th>Material</th>
                                        <th>Qty</th>
                                        <th>Area (m²)</th>
                                    </tr>
                                </thead>
                                <tbody id="partsTableBody">
                                    <tr>
                                        <td colspan="7" style="text-align: center; color: #656d76; padding: 20px;">No parts to display</td>
                                    </tr>
                                </tbody>
                            </table>
                        </div>
                    </div>
                </div>
                
                <!-- RIGHT COLUMN: STOCK MATERIALS & PRICING -->
                <div class="section">
                    <div class="section-header" onclick="toggleSection(this)">
                        <span class="section-title">Stock Materials & Pricing - Used Only (<span id="materialCount">0</span>)</span>
                        <span class="section-toggle"></span>
                    </div>
                    <div class="section-content" style="padding: 0;">
                        <div style="background: #f8fafc; border-bottom: 1px solid #e1e5e9; padding: 16px 24px; display: flex; gap: 12px; align-items: center; flex-wrap: wrap;">
                            <!-- SIMPLIFIED TOOLBAR: Only Export Database and Search -->
                            <button type="button" onclick="exportDatabase()" class="btn-sm">Export Database</button>
                            <input type="text" id="materialSearchInput" placeholder="Search materials..." oninput="displayMaterials()" style="flex: 1; min-width: 200px; padding: 8px 12px; border: 1px solid #d0d7de; border-radius: 6px; font-size: 13px;">
                            
                            <!-- COMMENTED OUT: Material management buttons - not needed for used-only view -->
                            <!--
                            <button type="button" onclick="addMaterial()" class="btn-sm">Add Material</button>
                            <button type="button" onclick="loadDefaults()" class="btn-sm">Load Defaults</button>
                            <button type="button" onclick="importCSV()" class="btn-sm">Import CSV</button>
                            <div style="width: 1px; height: 24px; background: #d0d7de; margin: 0 4px;"></div>
                            <button type="button" onclick="clearHighlight()" class="btn-sm">Clear Highlight</button>
                            <button type="button" onclick="purgeOldAutoMaterials()" class="btn-sm" style="background: #dc3545; color: white; border-color: #dc3545;">Purge Old Auto</button>
                            <select id="sortBy" onchange="displayMaterials()" style="padding: 8px 12px; border: 1px solid #d0d7de; border-radius: 6px; font-size: 13px; background: white;">
                                <option value="alphabetical">Sort: A-Z</option>
                                <option value="usage">Sort: Used First</option>
                                <option value="mostUsed">Sort: Most Used</option>
                            </select>
                            <div style="width: 1px; height: 24px; background: #d0d7de; margin: 0 4px;"></div>
                            -->
                        </div>
                        <div style="overflow-y: auto; overflow-x: auto; max-height: 600px;">
                            <table class="google-sheets-table" id="materialsTable">
                                <thead>
                                    <tr>
                                        <th>Material Name</th>
                                        <th>Width (mm)</th>
                                        <th>Height (mm)</th>
                                        <th>Thickness (mm)</th>
                                        <th>Density (kg/m³)</th>
                                        <th>Price per Sheet</th>
                                        <th style="text-align: center;">Actions</th>
                                    </tr>
                                </thead>
                                <tbody id="materials_tbody">
                                    <tr>
                                        <td colspan="7" style="text-align: center; color: #656d76; padding: 20px;">No materials available</td>
                                    </tr>
                                </tbody>
                            </table>
                        </div>
                    </div>
                </div>
                
            </div>
            <!-- END TWO COLUMN LAYOUT -->
            
        </div>
    </div>

    <!-- Report Tab -->
    <div id="reportTabContent" class="tab-content">
        <div class="container">
            <div id="diagramsContainer" class="diagrams-container">
                <p>Generate a report to view diagrams...</p>
            </div>
            <div class="resizer" id="resizer"></div>
            <div id="reportContainer" class="report-container">

                <!-- Summary Cards -->
                <div class="summary-cards-container" style="display: grid; grid-template-columns: repeat(5, 1fr); gap: 20px; margin-bottom: 30px;">
                    <div class="glass-card" style="background: #ffffff; color: #24292e; padding: 24px; border-radius: 8px; box-shadow: 0 1px 3px rgba(0,0,0,0.08); border: 1px solid #d0d7de; transition: all 0.3s ease; cursor: pointer;">
                        <div style="font-size: 13px; color: #656d76; margin-bottom: 8px; font-weight: 500;">Total Cost</div>
                        <div id="summaryTotalCost" style="font-size: 28px; font-weight: 700; margin-bottom: 4px; color: #24292e;">$0.00</div>
                        <div style="font-size: 11px; color: #656d76;">Project total</div>
                    </div>
                    <div class="glass-card" style="background: #ffffff; color: #24292e; padding: 24px; border-radius: 8px; box-shadow: 0 1px 3px rgba(0,0,0,0.08); border: 1px solid #d0d7de; transition: all 0.3s ease; cursor: pointer;">
                        <div style="font-size: 13px; color: #656d76; margin-bottom: 8px; font-weight: 500;">Number of Materials</div>
                        <div id="summaryMaterialCount" style="font-size: 28px; font-weight: 700; margin-bottom: 4px; color: #24292e;">0</div>
                        <div style="font-size: 11px; color: #656d76;">Unique materials</div>
                    </div>
                    <div class="glass-card" style="background: #ffffff; color: #24292e; padding: 24px; border-radius: 8px; box-shadow: 0 1px 3px rgba(0,0,0,0.08); border: 1px solid #d0d7de; transition: all 0.3s ease; cursor: pointer;">
                        <div style="font-size: 13px; color: #656d76; margin-bottom: 8px; font-weight: 500;">Total Boards</div>
                        <div id="summaryTotalBoards" style="font-size: 28px; font-weight: 700; margin-bottom: 4px; color: #24292e;">0</div>
                        <div style="font-size: 11px; color: #656d76;">Sheets required</div>
                    </div>
                    <div class="glass-card" style="background: #ffffff; color: #24292e; padding: 24px; border-radius: 8px; box-shadow: 0 1px 3px rgba(0,0,0,0.08); border: 1px solid #d0d7de; transition: all 0.3s ease; cursor: pointer;">
                        <div style="font-size: 13px; color: #656d76; margin-bottom: 8px; font-weight: 500;">Overall Efficiency</div>
                        <div id="summaryOverallEfficiency" style="font-size: 28px; font-weight: 700; margin-bottom: 4px; color: #24292e;">0%</div>
                        <div style="font-size: 11px; color: #656d76;">Material usage</div>
                    </div>
                    <div class="glass-card" style="background: #ffffff; color: #24292e; padding: 24px; border-radius: 8px; box-shadow: 0 1px 3px rgba(0,0,0,0.08); border: 1px solid #d0d7de; transition: all 0.3s ease; cursor: pointer;">
                        <div style="font-size: 13px; color: #656d76; margin-bottom: 8px; font-weight: 500;">Total Parts</div>
                        <div id="summaryTotalParts" style="font-size: 28px; font-weight: 700; margin-bottom: 4px; color: #24292e;">0</div>
                        <div style="font-size: 11px; color: #656d76;">Part instances</div>
                    </div>
                </div>

                <h2 data-translate="materials_used">Materials Used</h2>
                <button type="button" id="treeToggle" onclick="toggleTreeView()" style="background: #007cba; color: white; padding: 10px 20px; font-size: 14px; font-weight: 600; margin-bottom: 15px; border: none; border-radius: 6px; cursor: pointer;">Show Component Tree</button>
                <div id="treeStructure" class="tree-structure" style="display: none;"></div>
                <div class="tree-search" id="treeSearchContainer" style="display: none; margin-bottom: 20px;">
                    <input type="text" id="treeSearch" placeholder="Search components..." oninput="filterTree()" style="padding: 8px; margin-right: 10px;">
                    <button type="button" onclick="clearTreeSearch()" style="padding: 8px 15px;">Clear</button>
                    <button type="button" onclick="expandAll()" style="padding: 8px 15px;">Expand All</button>
                    <button type="button" onclick="collapseAll()" style="padding: 8px 15px;">Collapse All</button>
                </div>
                <div class="table-with-controls">
                    <div class="table-controls">
                        <button class="icon-btn" onclick="openTableCustomization('materialsUsedTable')" title="Customize Table">
                            <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                                <rect x="3" y="3" width="18" height="18" rx="2" ry="2"/>
                                <path d="M9 9h6v6H9z"/>
                                <path d="M9 3v6M15 3v6M21 9H3M21 15H3"/>
                            </svg>
                        </button>
                        <button class="icon-btn" onclick="copyTableAsMarkdown('materialsUsedTable')" title="Copy Markdown">
                            <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                                <rect width="14" height="14" x="8" y="8" rx="2" ry="2"/>
                                <path d="M4 16c-1.1 0-2-.9-2-2V4c0-1.1.9-2 2-2h10c1.1 0 2 .9 2 2"/>
                            </svg>
                        </button>
                    </div>
                    <table id="materialsUsedTable"></table>
                </div>

                <h2 data-translate="overall_summary">Overall Summary</h2>
                <div class="table-with-controls">
                    <div class="table-controls">
                        <button class="icon-btn" onclick="openTableCustomization('summaryTable')" title="Customize Table">
                            <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                                <rect x="3" y="3" width="18" height="18" rx="2" ry="2"/>
                                <path d="M9 9h6v6H9z"/>
                                <path d="M9 3v6M15 3v6M21 9H3M21 15H3"/>
                            </svg>
                        </button>
                        <button class="icon-btn" onclick="copyTableAsMarkdown('summaryTable')" title="Copy Markdown">
                            <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                                <rect width="14" height="14" x="8" y="8" rx="2" ry="2"/>
                                <path d="M4 16c-1.1 0-2-.9-2-2V4c0-1.1.9-2 2-2h10c1.1 0 2 .9 2 2"/>
                            </svg>
                        </button>
                    </div>
                    <table id="summaryTable"></table>
                </div>

                <h2 data-translate="unique_part_types">Unique Part Types</h2>
                <div class="table-with-controls">
                    <div class="table-controls">
                        <button class="icon-btn" onclick="openTableCustomization('uniquePartTypesTable')" title="Customize Table">
                            <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                                <rect x="3" y="3" width="18" height="18" rx="2" ry="2"/>
                                <path d="M9 9h6v6H9z"/>
                                <path d="M9 3v6M15 3v6M21 9H3M21 15H3"/>
                            </svg>
                        </button>
                        <button class="icon-btn" onclick="copyTableAsMarkdown('uniquePartTypesTable')" title="Copy Markdown">
                            <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                                <rect width="14" height="14" x="8" y="8" rx="2" ry="2"/>
                                <path d="M4 16c-1.1 0-2-.9-2-2V4c0-1.1.9-2 2-2h10c1.1 0 2 .9 2 2"/>
                            </svg>
                        </button>
                    </div>
                    <table id="uniquePartTypesTable"></table>
                </div>

                <h2>Sheet Inventory Summary</h2>
                <div class="table-with-controls">
                    <div class="table-controls">
                        <button class="icon-btn" onclick="openTableCustomization('sheetInventoryTable')" title="Customize Table">
                            <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                                <rect x="3" y="3" width="18" height="18" rx="2" ry="2"/>
                                <path d="M9 9h6v6H9z"/>
                                <path d="M9 3v6M15 3v6M21 9H3M21 15H3"/>
                            </svg>
                        </button>
                        <button class="icon-btn" onclick="copyTableAsMarkdown('sheetInventoryTable')" title="Copy Markdown">
                            <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                                <rect width="14" height="14" x="8" y="8" rx="2" ry="2"/>
                                <path d="M4 16c-1.1 0-2-.9-2-2V4c0-1.1.9-2 2-2h10c1.1 0 2 .9 2 2"/>
                            </svg>
                        </button>
                    </div>
                    <table id="sheetInventoryTable"></table>
                </div>
                
                <h2>Cut Sequences</h2>
                <div id="cutSequenceContainer"></div>
                

                
                <h2>Usable Offcuts</h2>
                <div class="table-with-controls">
                    <div class="table-controls">
                        <button class="icon-btn" onclick="openTableCustomization('offcutsTable')" title="Customize Table">
                            <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                                <rect x="3" y="3" width="18" height="18" rx="2" ry="2"/>
                                <path d="M9 9h6v6H9z"/>
                                <path d="M9 3v6M15 3v6M21 9H3M21 15H3"/>
                            </svg>
                        </button>
                        <button class="icon-btn" onclick="copyTableAsMarkdown('offcutsTable')" title="Copy Markdown">
                            <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                                <rect width="14" height="14" x="8" y="8" rx="2" ry="2"/>
                                <path d="M4 16c-1.1 0-2-.9-2-2V4c0-1.1.9-2 2-2h10c1.1 0 2 .9 2 2"/>
                            </svg>
                        </button>
                    </div>
                    <table id="offcutsTable"></table>
                </div>
                
                <div id="assemblyViewsContainer"></div>
                
                <h2 data-translate="parts_placed_detailed">Cut List & Part Details</h2>
                <div class="table-with-controls">
                    <div class="table-controls">
                        <button class="icon-btn" onclick="openTableCustomization('partsTable')" title="Customize Table">
                            <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                                <rect x="3" y="3" width="18" height="18" rx="2" ry="2"/>
                                <path d="M9 9h6v6H9z"/>
                                <path d="M9 3v6M15 3v6M21 9H3M21 15H3"/>
                            </svg>
                        </button>
                        <button class="icon-btn" onclick="copyTableAsMarkdown('partsTable')" title="Copy Markdown">
                            <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                                <rect width="14" height="14" x="8" y="8" rx="2" ry="2"/>
                                <path d="M4 16c-1.1 0-2-.9-2-2V4c0-1.1.9-2 2-2h10c1.1 0 2 .9 2 2"/>
                            </svg>
                        </button>
                    </div>
                    <table id="partsTable"></table>
                </div>
            </div>
        </div>
    </div>

    <!-- Table Customization Panel -->
    <div id="tableCustomizationPanel" class="table-customization-panel">
        <h3 id="panelTitle">Table Settings</h3>
        
        <div class="table-setting-group">
            <h4>Appearance</h4>
            <div class="table-setting-row">
                <label>Font Size:</label>
                <select id="tableFontSize" onchange="applyTableSetting('fontSize', this.value)">
                    <option value="12px">Small</option>
                    <option value="14px" selected>Normal</option>
                    <option value="16px">Large</option>
                </select>
            </div>
            <div class="table-setting-row">
                <label>Cell Padding:</label>
                <select id="tableCellPadding" onchange="applyTableSetting('cellPadding', this.value)">
                    <option value="4px 8px">Compact</option>
                    <option value="8px 12px" selected>Normal</option>
                    <option value="12px 16px">Spacious</option>
                </select>
            </div>
        </div>
        
        <div class="table-setting-group">
            <h4>Colors</h4>
            <div class="table-setting-row">
                <label>Header Background:</label>
                <input type="color" id="tableHeaderBg" class="color-input" value="#f5f5f5" onchange="applyTableSetting('headerBg', this.value)">
            </div>
            <div class="table-setting-row">
                <label>Header Text:</label>
                <input type="color" id="tableHeaderColor" class="color-input" value="#000000" onchange="applyTableSetting('headerColor', this.value)">
            </div>
            <div class="table-setting-row">
                <label>Row Hover:</label>
                <input type="color" id="tableRowHover" class="color-input" value="#f6f8fa" onchange="applyTableSetting('rowHover', this.value)">
            </div>
        </div>
        
        <div class="table-setting-group">
            <h4>Alignment</h4>
            <div class="table-setting-row">
                <label>Text Align:</label>
                <select id="tableTextAlign" onchange="applyTableSetting('textAlign', this.value)">
                    <option value="left" selected>Left</option>
                    <option value="center">Center</option>
                    <option value="right">Right</option>
                </select>
            </div>
            <div class="table-setting-row">
                <label>Vertical Align:</label>
                <select id="tableVerticalAlign" onchange="applyTableSetting('verticalAlign', this.value)">
                    <option value="top">Top</option>
                    <option value="middle" selected>Middle</option>
                    <option value="bottom">Bottom</option>
                </select>
            </div>
        </div>
        
        <div class="table-setting-group">
            <h4>Text Wrapping</h4>
            <div class="table-setting-row">
                <label>Text Wrap:</label>
                <select id="tableTextWrap" onchange="applyTableSetting('textWrap', this.value)">
                    <option value="nowrap">No Wrap (Clip)</option>
                    <option value="normal" selected>Wrap Text</option>
                    <option value="break-word">Break Words</option>
                </select>
            </div>
        </div>
        
        <div class="table-setting-group">
            <h4>Borders</h4>
            <div class="table-setting-row">
                <label>Border Width:</label>
                <select id="tableBorderWidth" onchange="applyTableSetting('borderWidth', this.value)">
                    <option value="0px">None</option>
                    <option value="1px" selected>Light</option>
                    <option value="2px">Medium</option>
                    <option value="3px">Heavy</option>
                </select>
            </div>
            <div class="table-setting-row">
                <label>Border Color:</label>
                <input type="color" id="tableBorderColor" class="color-input" value="#d0d7de" onchange="applyTableSetting('borderColor', this.value)">
            </div>
        </div>
        
        <div class="template-section">
            <h4>Templates</h4>
            <div class="template-controls">
                <select id="individualTemplateSelector" onchange="loadIndividualTemplate()">
                    <option value="">Select Template...</option>
                </select>
            </div>
        </div>
        
        <div class="panel-buttons">
            <button onclick="saveCurrentAsTemplate()" class="icon-btn" title="Save as Template">
                <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                    <path d="M19 21H5a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h11l5 5v11a2 2 0 0 1-2 2z"/>
                    <polyline points="17,21 17,13 7,13 7,21"/>
                    <polyline points="7,3 7,8 15,8"/>
                </svg>
                <span>Save as Template</span>
            </button>
            <button onclick="applyCurrentTableSettings()" class="icon-btn primary" title="Apply">
                <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                    <polyline points="20,6 9,17 4,12"/>
                </svg>
                <span>Apply</span>
            </button>
            <button onclick="applyToGlobal()" class="icon-btn" title="Apply to Global">
                <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                    <circle cx="12" cy="12" r="10"/>
                    <line x1="2" y1="12" x2="22" y2="12"/>
                    <path d="M12 2a15.3 15.3 0 0 1 4 10 15.3 15.3 0 0 1-4 10 15.3 15.3 0 0 1-4-10 15.3 15.3 0 0 1 4-10z"/>
                </svg>
                <span>Apply to Global</span>
            </button>
            <button onclick="resetTableSettings()" class="icon-btn" title="Reset">
                <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                    <path d="M3 12a9 9 0 0 1 9-9 9.75 9.75 0 0 1 6.74 2.74L21 8"/>
                    <path d="M21 3v5h-5"/>
                    <path d="M21 12a9 9 0 0 1-9 9 9.75 9.75 0 0 1-6.74-2.74L3 16"/>
                    <path d="M3 21v-5h5"/>
                </svg>
                <span>Reset</span>
            </button>
            <button onclick="closeTableCustomization()" class="icon-btn" title="Close">
                <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                    <line x1="18" y1="6" x2="6" y2="18"/>
                    <line x1="6" y1="6" x2="18" y2="18"/>
                </svg>
                <span>Close</span>
            </button>
        </div>
    </div>

    <!-- Modal overlay for table customization -->
    <div class="modal-overlay" onclick="closeTableCustomization()"></div>

    <!-- Template Manager Modal -->
    <div id="templateManagerModal" class="modal">
        <div class="modal-content template-manager-content">
            <span class="close" onclick="closeTemplateManager()">&times;</span>
            <h3>Template Manager</h3>
            
            <div class="template-categories">
                <div class="category-tabs">
                    <button class="category-tab active" onclick="showTemplateCategory('predefined')">Built-in Templates</button>
                    <button class="category-tab" onclick="showTemplateCategory('custom')">My Templates</button>
                </div>
                
                <div id="predefinedTemplates" class="template-category active">
                    <div class="template-grid" id="predefinedTemplateGrid"></div>
                </div>
                
                <div id="customTemplates" class="template-category">
                    <div class="template-actions">
                        <input type="file" id="templateImportFile" accept=".json" style="display: none;" onchange="importTemplateFile(this)">
                        <button onclick="document.getElementById('templateImportFile').click()">Import Template</button>
                        <button onclick="exportAllTemplates()">Export All Templates</button>
                    </div>
                    <div class="template-grid" id="customTemplateGrid"></div>
                </div>
            </div>
            
            <div class="template-manager-buttons">
                <button onclick="closeTemplateManager()">Close</button>
            </div>
        </div>
    </div>

    <!-- Settings Modal -->
    <div id="settingsModal" class="modal">
        <div class="modal-content">
            <span class="close" onclick="closeSettings()">&times;</span>

            <div class="settings-section">
                <h3>Units</h3>
                <div style="display: flex; align-items: center; gap: 10px;">
                    <select id="settingsUnits" class="sort-select">
                        <option value="mm">Millimeters (mm)</option>
                        <option value="cm">Centimeters (cm)</option>
                        <option value="m">Meters (m)</option>
                        <option value="in">Inches (in)</option>
                        <option value="ft">Feet (ft)</option>
                    </select>
                    <button onclick="updateUnits()" class="icon-btn" title="Update Units">
                        <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                            <path d="M3 12a9 9 0 0 1 9-9 9.75 9.75 0 0 1 6.74 2.74L21 8"/>
                            <path d="M21 3v5h-5"/>
                            <path d="M21 12a9 9 0 0 1-9 9 9.75 9.75 0 0 1-6.74-2.74L3 16"/>
                            <path d="M3 21v-5h5"/>
                        </svg>
                    </button>
                </div>
            </div>
            <div class="settings-section">
                <h3>Precision</h3>
                <div style="display: flex; align-items: center; gap: 10px;">
                    <select id="settingsPrecision" class="sort-select">
                        <option value="0">0</option>
                        <option value="1">0.0</option>
                        <option value="2">0.00</option>
                        <option value="3">0.000</option>
                    </select>
                    <button onclick="updatePrecision()" class="icon-btn" title="Update Precision">
                        <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                            <path d="M3 12a9 9 0 0 1 9-9 9.75 9.75 0 0 1 6.74 2.74L21 8"/>
                            <path d="M21 3v5h-5"/>
                            <path d="M21 12a9 9 0 0 1-9 9 9.75 9.75 0 0 1-6.74-2.74L3 16"/>
                            <path d="M3 21v-5h5"/>
                        </svg>
                    </button>
                </div>
            </div>
            <div class="settings-section">
                <h3>Area Units</h3>
                <div style="display: flex; align-items: center; gap: 10px;">
                    <select id="settingsAreaUnits" class="sort-select">
                        <option value="mm2">Square Millimeters (mm²)</option>
                        <option value="cm2">Square Centimeters (cm²)</option>
                        <option value="m2">Square Meters (m²)</option>
                        <option value="in2">Square Inches (in²)</option>
                        <option value="ft2">Square Feet (ft²)</option>
                    </select>
                    <button onclick="updateAreaUnits()" class="icon-btn" title="Update Area Units">
                        <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                            <path d="M3 12a9 9 0 0 1 9-9 9.75 9.75 0 0 1 6.74 2.74L21 8"/>
                            <path d="M21 3v5h-5"/>
                            <path d="M21 12a9 9 0 0 1-9 9 9.75 9.75 0 0 1-6.74-2.74L3 16"/>
                            <path d="M3 21v-5h5"/>
                        </svg>
                    </button>
                </div>
            </div>
            <div class="settings-section">
                <h3>Default Currency</h3>
                <div style="display: flex; align-items: center; gap: 10px;">
                    <select id="settingsCurrency" class="sort-select">
                        <option value="USD">USD ($)</option>
                        <option value="EUR">EUR (€)</option>
                        <option value="SAR">SAR (ر.س)</option>
                        <option value="AED">AED (د.إ)</option>
                        <option value="GBP">GBP (£)</option>
                    </select>
                    <button onclick="updateCurrency()" class="icon-btn" title="Update Currency">
                        <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                            <path d="M3 12a9 9 0 0 1 9-9 9.75 9.75 0 0 1 6.74 2.74L21 8"/>
                            <path d="M21 3v5h-5"/>
                            <path d="M21 12a9 9 0 0 1-9 9 9.75 9.75 0 0 1-6.74-2.74L3 16"/>
                            <path d="M3 21v-5h5"/>
                        </svg>
                    </button>
                </div>
            </div>
            <div class="settings-buttons">
                <button onclick="closeSettings()" class="primary">Close</button>
            </div>
        </div>
    </div>

    <!-- Modal for enlarged part view -->
    <div id="partModal" class="modal">
        <div class="modal-content">
            <span class="close">&times;</span>
            <div class="modal-controls">
                <button id="projectionToggle">Orthographic</button>
            </div>
            <canvas id="modalCanvas" width="500" height="400"></canvas>
            <div id="modalInfo"></div>
        </div>
    </div>

    <!-- Dashboard Tab -->
    <div id="dashboardTabContent" class="tab-content">
        <div class="dashboard-container" style="padding: 32px; overflow-y: auto; background: #f6f8fa;">
            <div style="max-width: 1400px; margin: 0 auto;">
                <!-- Dashboard Header -->
                <div style="margin-bottom: 32px;">
                    <h1 style="margin: 0 0 8px 0; font-size: 32px; font-weight: 700; color: #24292e;">Project Dashboard</h1>
                    <p style="margin: 0; font-size: 16px; color: #656d76;">Visual analytics and insights for your cutting project</p>
                </div>

                <!-- Dashboard Content will be populated by JavaScript -->
                <div id="dashboardContent"></div>
            </div>
        </div>
    </div>

    <!-- Material Warning Modal -->
    <div id="materialWarningModal" class="modal" style="z-index: 10001;">
        <div class="modal-content" style="max-width: 700px; border-left: 4px solid #ff9800;">
            <span class="close" onclick="closeMaterialWarning()">&times;</span>
            <div style="display: flex; align-items: flex-start; gap: 16px; margin-bottom: 20px;">
                <div style="flex-shrink: 0; width: 48px; height: 48px; background: #fff3e0; border-radius: 50%; display: flex; align-items: center; justify-content: center;">
                    <svg width="28" height="28" viewBox="0 0 24 24" fill="none" stroke="#ff9800" stroke-width="2">
                        <path d="M10.29 3.86L1.82 18a2 2 0 0 0 1.71 3h16.94a2 2 0 0 0 1.71-3L13.71 3.86a2 2 0 0 0-3.42 0z"/>
                        <line x1="12" y1="9" x2="12" y2="13"/>
                        <line x1="12" y1="17" x2="12.01" y2="17"/>
                    </svg>
                </div>
                <div style="flex: 1;">
                    <h3 style="margin: 0 0 12px 0; color: #ff9800; font-size: 20px; font-weight: 600;">Material Compatibility Issues</h3>
                    <p style="color: #656d76; margin: 0 0 16px 0; font-size: 14px;">The following components don't match their sheet specifications:</p>
                    <div id="materialWarningContent" style="max-height: 400px; overflow-y: auto;"></div>
                </div>
            </div>
            <div style="text-align: right; padding-top: 16px; border-top: 1px solid #d0d7de;">
                <button onclick="closeMaterialWarning()" style="background: #ff9800; color: white; border: none; padding: 10px 24px; border-radius: 6px; cursor: pointer; font-size: 14px; font-weight: 500;">Got it</button>
            </div>
        </div>
    </div>


    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
    <script>
        // Global functions - must be defined before app.js loads
        let canvas3DScene, canvas3DCamera, canvas3DRenderer, canvas3DCurrentMesh;
        let viewer3DActive = false;
        
        // --- 3D Viewer Globals ---
        let assemblyMeshes = []; // Stores all 3D parts
        let isAssemblyMode = false; // Tracks if we are showing full assembly
        
        let allComponentsData = [];
        let currentComponentIndex = -1;
        let dimensionsVisible = false;
        let dimensionGroup = null;
        let rotationEnabled = false;
        let gridHelper = null;
        let textureMode = false;
        let geometryCache = {};
        let currentTexture = null;
        let dimensionTextSize = 40;
        let isOrthographic = false;

        function adjustDimensionSize(delta) {
            dimensionTextSize = Math.max(20, Math.min(100, dimensionTextSize + delta));
            if (dimensionsVisible) {
                toggleDimensions();
                toggleDimensions();
            }
        }
        
        function toggleProjection() {
            if (!canvas3DCamera || !canvas3DCurrentMesh) return;
            isOrthographic = !isOrthographic;
            const container = document.getElementById('parts3DCanvas').parentElement;
            const aspect = container.clientWidth / container.clientHeight;
            if (isOrthographic) {
                const comp = allComponentsData[currentComponentIndex];
                const maxDim = Math.max(comp.width, comp.height, comp.thickness);
                const frustumSize = maxDim * 2;
                canvas3DCamera = new THREE.OrthographicCamera(
                    frustumSize * aspect / -2, frustumSize * aspect / 2,
                    frustumSize / 2, frustumSize / -2, 0.1, 10000
                );
            } else {
                canvas3DCamera = new THREE.PerspectiveCamera(45, aspect, 0.1, 10000);
            }
            canvas3DCamera.position.copy(orbitControls.object.position);
            canvas3DCamera.lookAt(0, 0, 0);
            orbitControls.object = canvas3DCamera;
            orbitControls.update();
            renderOnce();
        }
        
        function setView(view) {
            if (!canvas3DCamera || !canvas3DCurrentMesh) return;
            canvas3DCurrentMesh.rotation.set(0, 0, 0);
            const comp = allComponentsData[currentComponentIndex];
            const maxDim = Math.max(comp.width, comp.height, comp.thickness);
            const distance = maxDim * 2;
            switch(view) {
                case 'top': canvas3DCamera.position.set(0, distance, 0); break;
                case 'front': canvas3DCamera.position.set(0, 0, distance); break;
                case 'right': canvas3DCamera.position.set(distance, 0, 0); break;
                case 'iso': canvas3DCamera.position.set(distance * 0.75, distance * 0.6, distance * 0.75); break;
            }
            canvas3DCamera.lookAt(0, 0, 0);
            orbitControls.target.set(0, 0, 0);
            orbitControls.update();
            updateDimensionTextScale();
            renderOnce();
        }

        function toggleRotation() {
            rotationEnabled = !rotationEnabled;
            if (rotationEnabled) {
                animate3DCanvas();
            }
        }
        
        function toggleGrid() {
            if (gridHelper) {
                gridHelper.visible = !gridHelper.visible;
                renderOnce();
            }
        }
        
        function toggleTexture() {
            console.log('=== TOGGLE TEXTURE ===');
            console.log('Current textureMode:', textureMode);
            console.log('isAssemblyMode:', isAssemblyMode);
            
            textureMode = !textureMode;
            console.log('New textureMode:', textureMode);
            
            if (isAssemblyMode) {
                console.log('Assembly Mode - Processing', assemblyMeshes.length, 'meshes');
                
                // Handle Assembly Mode Textures
                assemblyMeshes.forEach((group, idx) => {
                    const mesh = group.children[0]; // Access mesh inside group
                    if (mesh && mesh.material) {
                        if (textureMode) {
                            // Prepare material for texture display
                            mesh.material.transparent = false;
                            mesh.material.opacity = 1.0;
                            mesh.material.color.setHex(0xFFFFFF);
                            console.log(`Mesh ${idx} prepared for texture:`, group.userData.partName);
                        } else {
                            // Revert to base shaded mode
                            mesh.material.map = null;
                            mesh.material.transparent = true;
                            mesh.material.opacity = 0.85;
                            mesh.material.color.setHex(0xcccccc);
                            mesh.material.needsUpdate = true;
                            console.log(`Mesh ${idx} reverted to shaded:`, group.userData.partName);
                        }
                    }
                });
                
                // If turning on, load textures for all unique materials
                if (textureMode) {
                    const uniqueMaterials = new Set();
                    assemblyMeshes.forEach(group => {
                        if (group.userData.materialName) {
                            uniqueMaterials.add(group.userData.materialName);
                        }
                    });
                    
                    console.log('Unique materials found:', Array.from(uniqueMaterials));
                    
                    // Request textures for all unique materials
                    uniqueMaterials.forEach(materialName => {
                        if (typeof callRuby === 'function') {
                            console.log('Requesting texture for:', materialName);
                            callRuby('get_material_texture', materialName);
                        } else {
                            console.error('callRuby function not available!');
                        }
                    });
                }
                renderOnce();
            } else {
                // Single Mode logic
                if (!canvas3DCurrentMesh) return;
                
                if (textureMode) {
                    loadTextureForCurrentComponent();
                } else {
                    if (currentTexture) {
                        currentTexture.dispose();
                        currentTexture = null;
                    }
                    if (canvas3DCurrentMesh.material) {
                        canvas3DCurrentMesh.material.map = null;
                        canvas3DCurrentMesh.material.color.setHex(0x2323FF);
                        canvas3DCurrentMesh.material.needsUpdate = true;
                        renderOnce();
                    }
                }
            }
        }
        
        function renderOnce() {
            if (canvas3DRenderer && canvas3DScene && canvas3DCamera) {
                canvas3DRenderer.render(canvas3DScene, canvas3DCamera);
            }
        }
        
        function disposeCurrentMesh() {
            if (canvas3DCurrentMesh) {
                canvas3DCurrentMesh.children.forEach(child => {
                    if (child.geometry) child.geometry.dispose();
                    if (child.material) {
                        if (Array.isArray(child.material)) {
                            child.material.forEach(mat => mat.dispose());
                        } else {
                            child.material.dispose();
                        }
                    }
                });
                
                if (canvas3DCurrentMesh.material) {
                    if (canvas3DCurrentMesh.material.map) {
                        canvas3DCurrentMesh.material.map.dispose();
                    }
                    canvas3DCurrentMesh.material.dispose();
                }
                
                canvas3DScene.remove(canvas3DCurrentMesh);
                canvas3DCurrentMesh = null;
            }
            
            if (currentTexture) {
                currentTexture.dispose();
                currentTexture = null;
            }
        }
        
        function loadTextureForCurrentComponent() {
            if (currentComponentIndex < 0 || !allComponentsData[currentComponentIndex]) return;
            
            const comp = allComponentsData[currentComponentIndex];
            const rows = document.querySelectorAll('#partsTableBody tr');
            if (currentComponentIndex >= rows.length) return;
            
            const materialCell = rows[currentComponentIndex].cells[4];
            if (!materialCell) return;
            
            const materialName = materialCell.textContent.trim();
            
            if (typeof callRuby === 'function') {
                callRuby('get_material_texture', materialName);
            }
        }
        
        // Global texture cache: materialName -> THREE.Texture
        let textureCache = {};
        
        function applyMaterialToMesh(materialData) {
            console.log('=== APPLY MATERIAL TO MESH ===');
            console.log('materialData:', materialData);
            console.log('isAssemblyMode:', isAssemblyMode);
            
            if (!materialData || !materialData.name) {
                console.error('No material data provided!');
                return;
            }

            const materialName = materialData.name;
            const hasTexture = materialData.has_texture && materialData.texture;
            const color = materialData.color || 0xcccccc;
            const alpha = materialData.alpha !== undefined ? materialData.alpha : 1.0;
            
            console.log('Material:', materialName, 'hasTexture:', hasTexture, 'color:', color.toString(16), 'alpha:', alpha);

            if (hasTexture) {
                // Load texture
                const loader = new THREE.TextureLoader();
                console.log('Loading texture with THREE.TextureLoader...');
                
                loader.load(
                    materialData.texture,
                    (texture) => {
                        console.log('✓ Texture loaded successfully for material:', materialName);
                        console.log('Texture size:', texture.image.width, 'x', texture.image.height);
                        
                        texture.wrapS = THREE.RepeatWrapping;
                        texture.wrapT = THREE.RepeatWrapping;
                        
                        textureCache[materialName] = texture;
                        
                        applyMaterialProperties(materialName, { texture, color, alpha, hasTexture: true });
                    },
                    undefined,
                    (error) => {
                        console.error('✗ Error loading texture for', materialName, ':', error);
                    }
                );
            } else {
                // No texture, just apply color and opacity
                console.log('No texture, applying color and opacity only');
                applyMaterialProperties(materialName, { color, alpha, hasTexture: false });
            }
        }
        
        function applyMaterialProperties(materialName, props) {
            if (isAssemblyMode) {
                console.log('Applying material properties in assembly mode for:', materialName);
                
                let appliedCount = 0;
                assemblyMeshes.forEach((group, idx) => {
                    const mesh = group.children[0];
                    if (mesh && mesh.isMesh && mesh.material) {
                        if (group.userData.materialName === materialName) {
                            console.log(`Mesh ${idx} (${group.userData.partName}): Applying material properties`);
                            
                            if (props.hasTexture && props.texture) {
                                // Apply texture
                                props.texture.repeat.set(1, 1);
                                mesh.material.map = props.texture;
                                mesh.material.color.setHex(0xFFFFFF);
                                mesh.material.transparent = props.alpha < 1.0;
                                mesh.material.opacity = props.alpha;
                            } else {
                                // Apply color and opacity only
                                mesh.material.map = null;
                                mesh.material.color.setHex(props.color);
                                mesh.material.transparent = props.alpha < 1.0;
                                mesh.material.opacity = props.alpha;
                            }
                            
                            mesh.material.needsUpdate = true;
                            appliedCount++;
                        }
                    }
                });
                
                console.log(`Material applied to ${appliedCount} meshes with material: ${materialName}`);
                renderOnce();
            } else {
                // Single Mode
                console.log('Applying material in single mode');
                if (canvas3DCurrentMesh && canvas3DCurrentMesh.material) {
                    if (props.hasTexture && props.texture) {
                        const comp = allComponentsData[currentComponentIndex];
                        props.texture.repeat.set(comp.width / 1000, comp.height / 1000);
                        canvas3DCurrentMesh.material.map = props.texture;
                        canvas3DCurrentMesh.material.color.setHex(0xFFFFFF);
                    } else {
                        canvas3DCurrentMesh.material.map = null;
                        canvas3DCurrentMesh.material.color.setHex(props.color);
                    }
                    canvas3DCurrentMesh.material.transparent = props.alpha < 1.0;
                    canvas3DCurrentMesh.material.opacity = props.alpha;
                    canvas3DCurrentMesh.material.needsUpdate = true;
                    renderOnce();
                }
            }
        }
        
        // Keep old function for backward compatibility
        function applyTextureToMesh(textureData, materialName) {
            applyMaterialToMesh({
                name: materialName,
                texture: textureData,
                has_texture: true,
                color: 0xcccccc,
                alpha: 1.0
            });
        }
        
        // NEW: Handle both textured and non-textured materials
        function applyMaterialToMesh(materialProps) {
            console.log('=== APPLY MATERIAL TO MESH ===');
            console.log('Material properties:', materialProps);
            console.log('isAssemblyMode:', isAssemblyMode);
            
            if (!materialProps || !materialProps.name) {
                console.error('No material properties provided!');
                return;
            }
            
            const materialName = materialProps.name;
            const hasTexture = materialProps.has_texture;
            const color = materialProps.color;
            const alpha = materialProps.alpha;
            
            if (hasTexture && materialProps.texture) {
                // Material has a texture - load and apply it
                console.log('Material has texture - loading...');
                const loader = new THREE.TextureLoader();
                
                loader.load(
                    materialProps.texture,
                    (texture) => {
                        console.log('✓ Texture loaded successfully for material:', materialName);
                        console.log('Texture size:', texture.image.width, 'x', texture.image.height);
                        
                        texture.wrapS = THREE.RepeatWrapping;
                        texture.wrapT = THREE.RepeatWrapping;
                        
                        // Store in cache
                        textureCache[materialName] = texture;
                        
                        if (isAssemblyMode) {
                            // Assembly Mode: Apply texture ONLY to meshes with matching material
                            console.log('Applying texture in assembly mode to meshes with material:', materialName);
                            
                            let appliedCount = 0;
                            assemblyMeshes.forEach((group, idx) => {
                                const mesh = group.children[0];
                                if (mesh && mesh.isMesh && mesh.material) {
                                    // CRITICAL: Only apply if material matches
                                    if (group.userData.materialName === materialName) {
                                        const hasUVs = mesh.geometry.attributes.uv !== undefined;
                                        console.log(`Mesh ${idx} (${group.userData.partName}):`, 
                                            'hasUVs:', hasUVs,
                                            'material:', group.userData.materialName,
                                            '✓ APPLYING TEXTURE');
                                        
                                        if (!hasUVs) {
                                            console.warn(`Mesh ${idx} has no UV coordinates!`);
                                        }
                                        
                                        texture.repeat.set(1, 1);
                                        
                                        mesh.material.map = texture;
                                        mesh.material.color.setHex(0xFFFFFF);
                                        mesh.material.transparent = alpha < 1.0;
                                        mesh.material.opacity = alpha;
                                        mesh.material.needsUpdate = true;
                                        
                                        // STORE ORIGINAL MATERIAL PROPERTIES for restoration during selection
                                        group.userData.originalMaterial = {
                                            color: 0xFFFFFF,
                                            opacity: alpha,
                                            transparent: alpha < 1.0,
                                            map: texture
                                        };
                                        
                                        appliedCount++;
                                    }
                                }
                            });
                            
                            console.log(`Texture applied to ${appliedCount} meshes with material: ${materialName}`);
                            renderOnce();
                        } else {
                            // Single Mode: Apply to current mesh
                            console.log('Applying texture in single mode');
                            if (canvas3DCurrentMesh && canvas3DCurrentMesh.material) {
                                const comp = allComponentsData[currentComponentIndex];
                                texture.repeat.set(comp.width / 1000, comp.height / 1000);
                                
                                canvas3DCurrentMesh.material.map = texture;
                                canvas3DCurrentMesh.material.color.setHex(0xFFFFFF);
                                canvas3DCurrentMesh.material.transparent = alpha < 1.0;
                                canvas3DCurrentMesh.material.opacity = alpha;
                                canvas3DCurrentMesh.material.needsUpdate = true;
                                console.log('✓ Texture applied to single mesh');
                                renderOnce();
                            }
                        }
                    },
                    undefined,
                    (error) => {
                        console.error('✗ Error loading texture for', materialName, ':', error);
                    }
                );
            } else {
                // Material has NO texture - apply color and opacity only
                console.log('Material has no texture - applying color and opacity');
                console.log('Color:', color.toString(16), 'Alpha:', alpha);
                
                if (isAssemblyMode) {
                    // Assembly Mode: Apply color/opacity ONLY to meshes with matching material
                    let appliedCount = 0;
                    assemblyMeshes.forEach((group, idx) => {
                        const mesh = group.children[0];
                        if (mesh && mesh.isMesh && mesh.material) {
                            // CRITICAL: Only apply if material matches
                            if (group.userData.materialName === materialName) {
                                console.log(`Mesh ${idx} (${group.userData.partName}): Applying color/opacity for ${materialName}`);
                                console.log(`  Raw color value:`, color, `(type: ${typeof color})`);
                                console.log(`  Color as hex:`, '0x' + color.toString(16).padStart(6, '0'));
                                
                                // Remove any existing texture
                                mesh.material.map = null;
                                
                                // Apply color and opacity - ENSURE color is a number
                                const colorHex = typeof color === 'number' ? color : parseInt(color, 16);
                                mesh.material.color.setHex(colorHex);
                                mesh.material.transparent = alpha < 1.0;
                                mesh.material.opacity = alpha;
                                mesh.material.needsUpdate = true;
                                
                                console.log(`  Applied color:`, mesh.material.color.getHex().toString(16));
                                
                                // STORE ORIGINAL MATERIAL PROPERTIES for restoration during selection
                                group.userData.originalMaterial = {
                                    color: colorHex,
                                    opacity: alpha,
                                    transparent: alpha < 1.0,
                                    map: null
                                };
                                
                                appliedCount++;
                            }
                        }
                    });
                    
                    console.log(`Color/opacity applied to ${appliedCount} meshes with material: ${materialName}`);
                    renderOnce();
                } else {
                    // Single Mode: Apply to current mesh
                    console.log('Applying color/opacity in single mode');
                    if (canvas3DCurrentMesh && canvas3DCurrentMesh.material) {
                        canvas3DCurrentMesh.material.map = null;
                        canvas3DCurrentMesh.material.color.setHex(color);
                        canvas3DCurrentMesh.material.transparent = alpha < 1.0;
                        canvas3DCurrentMesh.material.opacity = alpha;
                        canvas3DCurrentMesh.material.needsUpdate = true;
                        console.log('✓ Color/opacity applied to single mesh');
                        renderOnce();
                    }
                }
            }
        }
        
        function reloadCurrentComponent() {
            if (currentComponentIndex < 0 || !allComponentsData[currentComponentIndex]) return;
            
            const comp = allComponentsData[currentComponentIndex];
            const rows = document.querySelectorAll('#partsTableBody tr');
            if (currentComponentIndex < rows.length) {
                selectPart(rows[currentComponentIndex], comp.name, comp.width, comp.height, comp.thickness);
            }
        }

        function capture3DSnapshot() {
            if (!viewer3DActive || !canvas3DCurrentMesh || currentComponentIndex < 0) {
                console.log('No component to capture');
                return;
            }
            
            const comp = allComponentsData[currentComponentIndex];
            const canvas = document.getElementById('parts3DCanvas');
            
            // Render high-res frame
            canvas3DRenderer.render(canvas3DScene, canvas3DCamera);
            
            // Capture image
            const imageData = canvas.toDataURL('image/png', 1.0);
            
            // Calculate area in square meters
            const areaSqm = (comp.width * comp.height / 1000000).toFixed(4);
            
            // Get material name from table row
            const rows = document.querySelectorAll('#partsTableBody tr');
            let materialName = 'NoMaterial';
            if (currentComponentIndex < rows.length) {
                const materialCell = rows[currentComponentIndex].cells[4];
                if (materialCell) {
                    materialName = materialCell.textContent.trim().replace(/[^\w]/g, '_');
                }
            }
            
            // Build filename: Type--WxHxTH--Material--Q--Asqm
            const cleanName = comp.name.replace(/[^\w]/g, '_');
            const filename = `${cleanName}--W${comp.width}xH${comp.height}xTH${comp.thickness}--${materialName}--Q1--A${areaSqm}sqm.png`;
            
            // Send to Ruby for saving
            if (typeof callRuby === 'function') {
                callRuby('save_3d_snapshot', JSON.stringify({
                    image_data: imageData,
                    filename: filename
                }));
            }
        }
        
        function showSnapshotSuccess(filepath) {
            // Change SNAP button to checkmark
            const snapButtons = document.querySelectorAll('.channel-button');
            let snapButton = null;
            snapButtons.forEach(btn => {
                if (btn.textContent.includes('SNAP')) {
                    snapButton = btn;
                }
            });
            
            if (snapButton) {
                const originalHTML = snapButton.innerHTML;
                snapButton.innerHTML = '<a href="#" onclick="event.preventDefault();">✓</a>';
                snapButton.style.background = '#4CAF50';
                
                setTimeout(() => {
                    snapButton.innerHTML = originalHTML;
                    snapButton.style.background = '';
                }, 1000);
            }
            
            // Show toast message above viewer
            const toast = document.createElement('div');
            toast.style.cssText = 'position: absolute; top: 10px; left: 50%; transform: translateX(-50%); background: rgba(76, 175, 80, 0.95); color: white; padding: 10px 20px; border-radius: 6px; font-size: 13px; font-weight: 600; box-shadow: 0 4px 12px rgba(0,0,0,0.3); opacity: 0; transition: opacity 0.3s; text-align: center; z-index: 1000; pointer-events: none;';
            toast.textContent = `Snapshot saved successfully`;
            
            const viewerScreen = document.getElementById('viewer3DScreen');
            viewerScreen.style.position = 'relative';
            viewerScreen.appendChild(toast);
            
            setTimeout(() => { toast.style.opacity = '1'; }, 10);
            setTimeout(() => { toast.style.opacity = '0'; }, 2000);
            setTimeout(() => { toast.remove(); }, 2300);
        }

        function toggleDimensions() {
            if (!viewer3DActive || !canvas3DCurrentMesh) return;
            dimensionsVisible = !dimensionsVisible;
            
            if (dimensionGroup) {
                canvas3DCurrentMesh.remove(dimensionGroup);
                dimensionGroup = null;
            }
            
            if (dimensionsVisible && allComponentsData[currentComponentIndex]) {
                const comp = allComponentsData[currentComponentIndex];
                const w = comp.width;
                const h = comp.height;
                const t = comp.thickness;
                
                dimensionGroup = new THREE.Group();
                
                const offset = Math.max(w, h, t) * 0.1;
                
                dimensionGroup.add(createDimension(
                    new THREE.Vector3(-w/2, -t/2, h/2),
                    new THREE.Vector3(w/2, -t/2, h/2),
                    new THREE.Vector3(0, 0, offset),
                    w.toFixed(0) + 'mm'
                ));
                
                dimensionGroup.add(createDimension(
                    new THREE.Vector3(w/2, -t/2, -h/2),
                    new THREE.Vector3(w/2, -t/2, h/2),
                    new THREE.Vector3(offset, 0, 0),
                    h.toFixed(0) + 'mm'
                ));
                
                dimensionGroup.add(createDimension(
                    new THREE.Vector3(-w/2, -t/2, h/2),
                    new THREE.Vector3(-w/2, t/2, h/2),
                    new THREE.Vector3(-offset, 0, 0),
                    t.toFixed(0) + 'mm'
                ));
                
                canvas3DCurrentMesh.add(dimensionGroup);
            }
            
            renderOnce();
        }
        
        function createTextSprite(message, color = 'black') {
            const canvas = document.createElement('canvas');
            const ctx = canvas.getContext('2d');
            const fontSize = 90;
            ctx.font = `bold ${fontSize}px Arial`;
            const textMetrics = ctx.measureText(message);
            const textWidth = textMetrics.width;
            canvas.width = textWidth + 40;
            canvas.height = fontSize + 40;
            
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            ctx.font = `bold ${fontSize}px Arial`;
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillStyle = 'black';
            ctx.fillText(message, canvas.width / 2, canvas.height / 2);
            
            const texture = new THREE.CanvasTexture(canvas);
            texture.minFilter = THREE.LinearFilter;
            texture.wrapS = THREE.ClampToEdgeWrapping;
            texture.wrapT = THREE.ClampToEdgeWrapping;
            const spriteMaterial = new THREE.SpriteMaterial({ 
                map: texture, 
                depthTest: false,
                depthWrite: false
            });
            const sprite = new THREE.Sprite(spriteMaterial);
            const fixedScale = dimensionTextSize;
            sprite.scale.set((canvas.width / fontSize) * fixedScale, fixedScale, 1);
            sprite.userData.isFixedSize = true;
            return sprite;
        }
        
        function createDimension(start, end, offsetVec, text) {
            const color = 0x2563eb;
            const subGroup = new THREE.Group();
            
            const lineGeo = new THREE.BufferGeometry().setFromPoints([
                new THREE.Vector3(start.x + offsetVec.x, start.y + offsetVec.y, start.z + offsetVec.z),
                new THREE.Vector3(end.x + offsetVec.x, end.y + offsetVec.y, end.z + offsetVec.z)
            ]);
            const lineMat = new THREE.LineBasicMaterial({ color: color, linewidth: 2 });
            subGroup.add(new THREE.Line(lineGeo, lineMat));
            
            const w1Geo = new THREE.BufferGeometry().setFromPoints([
                start, 
                new THREE.Vector3(start.x + offsetVec.x, start.y + offsetVec.y, start.z + offsetVec.z)
            ]);
            const w2Geo = new THREE.BufferGeometry().setFromPoints([
                end, 
                new THREE.Vector3(end.x + offsetVec.x, end.y + offsetVec.y, end.z + offsetVec.z)
            ]);
            const witnessMat = new THREE.LineBasicMaterial({ color: color, opacity: 0.7, transparent: true, linewidth: 2 });
            subGroup.add(new THREE.Line(w1Geo, witnessMat));
            subGroup.add(new THREE.Line(w2Geo, witnessMat));
            
            const arrowSize = Math.max(5, offsetVec.length() * 0.12);
            const arrowHeadGeo = new THREE.ConeGeometry(arrowSize * 0.4, arrowSize * 1.5, 8);
            const arrowHeadMat = new THREE.MeshBasicMaterial({ color: color });
            
            const startArrow = new THREE.Mesh(arrowHeadGeo, arrowHeadMat);
            const endArrow = new THREE.Mesh(arrowHeadGeo, arrowHeadMat);
            
            startArrow.position.set(start.x + offsetVec.x, start.y + offsetVec.y, start.z + offsetVec.z);
            startArrow.lookAt(new THREE.Vector3(end.x + offsetVec.x, end.y + offsetVec.y, end.z + offsetVec.z));
            startArrow.rotateX(Math.PI / 2);
            
            endArrow.position.set(end.x + offsetVec.x, end.y + offsetVec.y, end.z + offsetVec.z);
            endArrow.lookAt(new THREE.Vector3(start.x + offsetVec.x, start.y + offsetVec.y, start.z + offsetVec.z));
            endArrow.rotateX(Math.PI / 2);
            
            subGroup.add(startArrow);
            subGroup.add(endArrow);
            
            const sprite = createTextSprite(text, '#2563eb');
            const midX = (start.x + end.x) / 2 + offsetVec.x;
            const midY = (start.y + end.y) / 2 + offsetVec.y;
            const midZ = (start.z + end.z) / 2 + offsetVec.z;
            const textOffset = offsetVec.clone().normalize().multiplyScalar(5);
            sprite.position.set(midX + textOffset.x, midY + textOffset.y, midZ + textOffset.z);
            sprite.renderOrder = 999;
            subGroup.add(sprite);
            
            return subGroup;
        }

        function switchToNextComponent() {
            if (!viewer3DActive) {
                console.log('Turn on 3D Viewer first');
                return;
            }
            if (allComponentsData.length === 0) {
                console.log('No components available');
                return;
            }
            
            currentComponentIndex = (currentComponentIndex + 1) % allComponentsData.length;
            const comp = allComponentsData[currentComponentIndex];
            
            const rows = document.querySelectorAll('#partsTableBody tr');
            rows.forEach((row, index) => {
                if (index === currentComponentIndex) {
                    row.classList.add('selected');
                    row.scrollIntoView({ behavior: 'smooth', block: 'center' });
                } else {
                    row.classList.remove('selected');
                }
            });
            
            if (dimensionGroup && canvas3DCurrentMesh) {
                canvas3DCurrentMesh.remove(dimensionGroup);
                dimensionGroup = null;
            }
            
            document.getElementById('canvasPlaceholder').style.display = 'none';
            document.getElementById('parts3DCanvas').style.display = 'block';
            document.getElementById('selectedPartName').textContent = comp.name;
            document.getElementById('selectedPartDims').textContent = `W: ${Math.round(comp.width)} × H: ${Math.round(comp.height)} × T: ${Math.round(comp.thickness)} mm`;
            const volume = (comp.width * comp.height * comp.thickness / 1000000000).toFixed(4);
            document.getElementById('selectedPartVolume').textContent = `${volume} m³`;
            
            disposeCurrentMesh();
            
            const geomKey = `${comp.width}_${comp.height}_${comp.thickness}`;
            let geometry = geometryCache[geomKey];
            if (!geometry) {
                geometry = new THREE.BoxGeometry(comp.width, comp.thickness, comp.height);
                geometryCache[geomKey] = geometry;
            }
            
            const materialColor = textureMode ? 0xFFFFFF : 0x2323FF;
            const material = new THREE.MeshPhongMaterial({ color: materialColor, transparent: true, opacity: 0.8 });
            canvas3DCurrentMesh = new THREE.Mesh(geometry, material);
            
            const edges = new THREE.EdgesGeometry(geometry);
            const lineMaterial = new THREE.LineBasicMaterial({ color: 0x000000, linewidth: 2 });
            const wireframe = new THREE.LineSegments(edges, lineMaterial);
            canvas3DCurrentMesh.add(wireframe);
            
            canvas3DScene.add(canvas3DCurrentMesh);
            
            const maxDim = Math.max(comp.width, comp.height, comp.thickness);
            canvas3DCamera.position.set(maxDim * 1.5, maxDim * 1.2, maxDim * 1.5);
            canvas3DCamera.lookAt(0, 0, 0);
            if (orbitControls) orbitControls.target.set(0, 0, 0);
            
            if (dimensionsVisible) {
                toggleDimensions();
                toggleDimensions();
            }
            
            if (textureMode) {
                loadTextureForCurrentComponent();
            }
            
            renderOnce();
        }

        let viewer3DAutoOffTimer = null;

        function resetAutoOffTimer() {
            if (viewer3DAutoOffTimer) {
                clearTimeout(viewer3DAutoOffTimer);
            }
            if (viewer3DActive) {
                viewer3DAutoOffTimer = setTimeout(() => {
                    if (viewer3DActive) {
                        toggle3DViewer();
                    }
                }, 120000); // 2 minutes
            }
        }

        function toggle3DViewer() {
            viewer3DActive = !viewer3DActive;
            const canvas = document.getElementById('parts3DCanvas');
            const offScreen = document.getElementById('viewer3DOffScreen');
            const placeholder = document.getElementById('canvasPlaceholder');
            const screen = document.getElementById('viewer3DScreen');
            const powerBtn = document.getElementById('viewer3DPowerBtn');
            const explodeCtrl = document.getElementById('explodeControls');
            
            if (viewer3DActive) {
                offScreen.style.display = 'none';
                screen.style.background = '#fafbfc';
                powerBtn.style.background = 'rgba(76, 175, 80, 0.3)';
                powerBtn.style.borderColor = 'rgba(76, 175, 80, 0.5)';
                document.getElementById('viewControls').style.display = 'flex';
                
                if (!canvas3DRenderer) init3DCanvas();
                
                // CHECK FOR ASSEMBLY DATA
                if (window.assemblyData && (window.assemblyData.parts || window.assemblyData.geometry)) {
                    isAssemblyMode = true;
                    placeholder.style.display = 'none';
                    canvas.style.display = 'block';
                    explodeCtrl.style.display = 'flex';
                    renderAssembly(window.assemblyData);
                } else {
                    // Fallback to single part mode
                    isAssemblyMode = false;
                    placeholder.style.display = 'block';
                    explodeCtrl.style.display = 'none';
                    populateComponentsArray();
                }
                
                animate3DCanvas();
                resetAutoOffTimer();
            } else {
                canvas.style.display = 'none';
                placeholder.style.display = 'none';
                offScreen.style.display = 'flex';
                screen.style.background = '#1a1a1a';
                powerBtn.style.background = 'rgba(255,255,255,0.2)';
                powerBtn.style.borderColor = 'rgba(255,255,255,0.4)';
                document.getElementById('viewControls').style.display = 'none';
                explodeCtrl.style.display = 'none';
                
                // Clear Scene
                if(isAssemblyMode) clearAssemblyScene();
                else disposeCurrentMesh();
                
                document.getElementById('selectedPartName').textContent = 'None';
                document.getElementById('selectedPartDims').textContent = '-';
                document.getElementById('selectedPartVolume').textContent = '-';
                
                if (viewer3DAutoOffTimer) {
                    clearTimeout(viewer3DAutoOffTimer);
                    viewer3DAutoOffTimer = null;
                }
            }
        }
        
        function convertGeometryToParts(geometry) {
            if (!geometry || !geometry.faces) return [];
            
            console.log('Converting geometry to parts:', geometry.faces.length, 'faces');
            
            // Convert faces array to parts format expected by renderAssembly
            return geometry.faces.map((face, index) => {
                // Flatten vertices from [{x,y,z}, {x,y,z}] to [x,y,z,x,y,z]
                const vertices = [];
                if (face.vertices && Array.isArray(face.vertices)) {
                    face.vertices.forEach(v => {
                        vertices.push(v.x || 0, v.y || 0, v.z || 0);
                    });
                }
                
                console.log(`Part ${index}: ${face.vertices?.length || 0} vertices -> ${vertices.length} floats`);
                
                return {
                    name: `Part ${index + 1}`,
                    vertices: vertices,
                    normals: [],
                    uvs: [],
                    colors: [face.color || 0x2323FF],
                    explode_vector: [0, 0, 1] // Default explode upward
                };
            });
        }
        
        function renderAssembly(data) {
            if (!canvas3DScene) return;
            clearAssemblyScene();

            const geometryData = data.geometry || data;
            if (!geometryData || !geometryData.parts || geometryData.parts.length === 0) {
                console.warn('No geometry parts to render');
                return;
            }

            console.log('Rendering assembly:', geometryData.parts.length, 'components');

            let allBounds = null;
            
            // Render each component as separate mesh
            geometryData.parts.forEach((partData, partIndex) => {
                const faces = partData.faces || [];
                if (faces.length === 0) return;

                const positions = [];
                const uvs = [];

                faces.forEach(face => {
                    const vertices = face.vertices;
                    const faceUVs = face.uvs;
                    if (!vertices || vertices.length < 3) return;
                    
                    // Triangulate and swap Y/Z
                    for (let i = 1; i < vertices.length - 1; i++) {
                        positions.push(vertices[0].x, vertices[0].z, -vertices[0].y);
                        positions.push(vertices[i].x, vertices[i].z, -vertices[i].y);
                        positions.push(vertices[i + 1].x, vertices[i + 1].z, -vertices[i + 1].y);
                        
                        // Push UVs if available
                        if (faceUVs && faceUVs.length === vertices.length) {
                            uvs.push(faceUVs[0].x, faceUVs[0].y);
                            uvs.push(faceUVs[i].x, faceUVs[i].y);
                            uvs.push(faceUVs[i + 1].x, faceUVs[i + 1].y);
                        } else {
                            // Fallback: generate simple UVs
                            uvs.push(0, 0);
                            uvs.push(0.5, 0);
                            uvs.push(0.5, 0.5);
                        }
                    }
                });

                if (positions.length === 0) return;

                const geometry = new THREE.BufferGeometry();
                geometry.setAttribute('position', new THREE.Float32BufferAttribute(positions, 3));
                
                // Always add UV attribute for texture support
                if (uvs.length > 0) {
                    geometry.setAttribute('uv', new THREE.Float32BufferAttribute(uvs, 2));
                }
                geometry.computeVertexNormals();

                // Create material ready for textures
                const material = new THREE.MeshStandardMaterial({ 
                    color: 0xcccccc,
                    metalness: 0.1,
                    roughness: 0.6,
                    side: THREE.DoubleSide,
                    transparent: true,
                    opacity: 0.85,
                    emissive: 0x000000,
                    emissiveIntensity: 1.0
                });
                
                const mesh = new THREE.Mesh(geometry, material);
                
                const edges = new THREE.EdgesGeometry(geometry, 15);
                const edgeMaterial = new THREE.LineBasicMaterial({ color: 0x666666 });
                const wireframe = new THREE.LineSegments(edges, edgeMaterial);
                
                const group = new THREE.Group();
                group.add(mesh);
                group.add(wireframe);
                
                group.userData = {
                    partName: partData.name,
                    materialName: partData.material || "Default Material",
                    explodeVector: new THREE.Vector3(...(partData.explode_vector || [0, 0, 0])),
                    originalPosition: group.position.clone(), // Will be updated after centering
                    // Store initial material properties for restoration during selection
                    originalMaterial: {
                        color: 0xcccccc,
                        opacity: 0.85,
                        transparent: true,
                        map: null
                    },
                    // Store original edge properties
                    originalEdgeColor: 0x666666
                };
                
                // Debug: Log explode vector for first part only
                if (partIndex === 0) {
                    console.log(`First part explode vector:`, partData.explode_vector);
                    console.log(`First part material:`, partData.material);
                }
                
                canvas3DScene.add(group);
                assemblyMeshes.push(group);
                
                // Track bounds
                const box = new THREE.Box3().setFromObject(group);
                if (!allBounds) {
                    allBounds = box;
                } else {
                    allBounds.union(box);
                }
            });

            if (assemblyMeshes.length === 0) {
                console.warn('No valid parts rendered');
                return;
            }

            // Center camera on all parts
            const center = allBounds.getCenter(new THREE.Vector3());
            const size = allBounds.getSize(new THREE.Vector3());
            const maxDim = Math.max(size.x, size.y, size.z);
            
            // Center all parts and store their centered position as the original
            assemblyMeshes.forEach(group => {
                group.position.sub(center);
                // Store the CENTERED position as the original position for explosion
                group.userData.originalPosition = group.position.clone();
            });
            
            const distance = maxDim * 2.5;
            canvas3DCamera.position.set(distance * 0.7, distance * 0.5, distance * 0.7);
            canvas3DCamera.lookAt(0, 0, 0);
            orbitControls.target.set(0, 0, 0);
            orbitControls.update();

            console.log('Assembly rendered:', assemblyMeshes.length, 'components');
            renderOnce();
        }

        function clearAssemblyScene() {
            assemblyMeshes.forEach(mesh => {
                canvas3DScene.remove(mesh);
                if(mesh.geometry) mesh.geometry.dispose();
                if(mesh.material) mesh.material.dispose();
            });
            assemblyMeshes = [];
        }

        function updateExplosion(val) {
            if (!isAssemblyMode || assemblyMeshes.length === 0) return;

            // Normalize slider
            const t = val / 100;
            
            // NON-LINEAR easing (critical)
            const eased = Math.pow(t, 2.2);
            
            // Much smaller base scale
            const explodeScale = 60;

            // Calculate center of mass shift
            const centerShift = new THREE.Vector3(0, 0, 0);
            
            assemblyMeshes.forEach(group => {
                const { explodeVector, originalPosition } = group.userData;
                if (!explodeVector || !originalPosition) return;
                
                const offset = explodeVector.clone().multiplyScalar(eased * explodeScale);
                centerShift.add(offset);
            });
            
            // Average the shift to find center of mass movement
            centerShift.divideScalar(assemblyMeshes.length);

            // Apply explosion but compensate for center shift
            assemblyMeshes.forEach(group => {
                const { explodeVector, originalPosition } = group.userData;
                if (!explodeVector || !originalPosition) return;
                
                const offset = explodeVector.clone().multiplyScalar(eased * explodeScale);
                group.position.copy(originalPosition).add(offset).sub(centerShift);
            });

            renderOnce();
        }
        
        function populateComponentsArray() {
            allComponentsData = [];
            const rows = document.querySelectorAll('#partsTableBody tr');
            rows.forEach(row => {
                const cells = row.cells;
                if (cells.length >= 4) {
                    allComponentsData.push({
                        name: cells[0].textContent,
                        width: parseFloat(cells[1].textContent) || 0,
                        height: parseFloat(cells[2].textContent) || 0,
                        thickness: parseFloat(cells[3].textContent) || 0
                    });
                }
            });
        }
        
        function toggleSection(header) {
            header.parentElement.classList.toggle('collapsed');
        }
        
        // Export Technical Drawings Function
        function exportTechnicalDrawings() {
            console.log('Export Technical Drawings clicked');
            if (typeof callRuby === 'function') {
                callRuby('export_technical_drawings');
            } else {
                alert('Export function not available');
            }
        }
        
        let orbitControls = null;
        let raycaster = null;
        let mouse = new THREE.Vector2();
        
        function init3DCanvas() {
            const canvas = document.getElementById('parts3DCanvas');
            const container = canvas.parentElement;
            
            canvas3DScene = new THREE.Scene();
            canvas3DScene.background = new THREE.Color(0xfafbfc);
            
            canvas3DCamera = new THREE.PerspectiveCamera(45, container.clientWidth / container.clientHeight, 0.1, 10000);
            canvas3DCamera.position.set(1000, 800, 1000);
            canvas3DCamera.lookAt(0, 0, 0);
            
            canvas3DRenderer = new THREE.WebGLRenderer({ 
                canvas: canvas, 
                antialias: true,
                preserveDrawingBuffer: true
            });
            canvas3DRenderer.setSize(container.clientWidth, container.clientHeight);
            
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
            canvas3DScene.add(ambientLight);
            const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
            directionalLight.position.set(500, 1000, 500);
            canvas3DScene.add(directionalLight);
            
            gridHelper = new THREE.GridHelper(2000, 20, 0xcccccc, 0xeeeeee);
            canvas3DScene.add(gridHelper);
            
            // Initialize raycaster for click detection
            raycaster = new THREE.Raycaster();
            
            orbitControls = new THREE.OrbitControls(canvas3DCamera, canvas);
            orbitControls.enableDamping = true;
            orbitControls.dampingFactor = 0.08;
            orbitControls.mouseButtons = {
                LEFT: null,  // Disable left click for orbit (we'll use it for selection)
                MIDDLE: THREE.MOUSE.ROTATE,
                RIGHT: THREE.MOUSE.PAN
            };
            orbitControls.enablePan = true;
            orbitControls.panSpeed = 0.8;
            orbitControls.rotateSpeed = 0.5;
            orbitControls.zoomSpeed = 1.2;
            
            orbitControls.addEventListener('change', renderOnce);
            
            // Add click event listener for part selection
            canvas.addEventListener('click', on3DViewerClick, false);
            
            // Change cursor to pointer when hovering over parts
            canvas.addEventListener('mousemove', on3DViewerMouseMove, false);
            
            // Set default cursor to pointer (not hand)
            canvas.style.cursor = 'pointer';
            
            renderOnce();
        }
        
        // Handle mouse move for hover effects
        function on3DViewerMouseMove(event) {
            if (!isAssemblyMode || assemblyMeshes.length === 0) return;
            
            const canvas = event.target;
            const rect = canvas.getBoundingClientRect();
            
            // Calculate mouse position in normalized device coordinates (-1 to +1)
            mouse.x = ((event.clientX - rect.left) / rect.width) * 2 - 1;
            mouse.y = -((event.clientY - rect.top) / rect.height) * 2 + 1;
            
            // Update raycaster
            raycaster.setFromCamera(mouse, canvas3DCamera);
            
            // Get all meshes from assembly groups
            const meshes = assemblyMeshes.map(group => group.children[0]).filter(m => m);
            const intersects = raycaster.intersectObjects(meshes, false);
            
            // Change cursor based on hover
            if (intersects.length > 0) {
                canvas.style.cursor = 'pointer';
            } else {
                canvas.style.cursor = 'default';
            }
        }
        
        // Handle click on 3D viewer
        function on3DViewerClick(event) {
            if (!isAssemblyMode || assemblyMeshes.length === 0) return;
            
            console.log('═══════════════════════════════════════════════════════');
            console.log('🖱️  3D VIEWER CLICK DEBUG START');
            console.log('═══════════════════════════════════════════════════════');
            
            const canvas = event.target;
            const rect = canvas.getBoundingClientRect();
            
            // Calculate mouse position in normalized device coordinates (-1 to +1)
            mouse.x = ((event.clientX - rect.left) / rect.width) * 2 - 1;
            mouse.y = -((event.clientY - rect.top) / rect.height) * 2 + 1;
            
            console.log('🖱️  Mouse position:', mouse.x.toFixed(3), mouse.y.toFixed(3));
            
            // Update raycaster
            raycaster.setFromCamera(mouse, canvas3DCamera);
            
            // Get all meshes from assembly groups
            const meshes = assemblyMeshes.map(group => group.children[0]).filter(m => m);
            console.log('🎨 Total meshes to check:', meshes.length);
            console.log('📊 Total assembly groups:', assemblyMeshes.length);
            
            const intersects = raycaster.intersectObjects(meshes, false);
            
            console.log('🎯 Intersects found:', intersects.length);
            
            if (intersects.length > 0) {
                // Find which group this mesh belongs to
                const clickedMesh = intersects[0].object;
                let clickedIndex = -1;
                
                console.log('🔍 Searching for clicked mesh in assemblyMeshes...');
                for (let i = 0; i < assemblyMeshes.length; i++) {
                    if (assemblyMeshes[i].children[0] === clickedMesh) {
                        clickedIndex = i;
                        console.log(`✅ Found at index ${i}`);
                        break;
                    }
                }
                
                if (clickedIndex >= 0) {
                    console.log('✅ Clicked on part index:', clickedIndex);
                    const group = assemblyMeshes[clickedIndex];
                    console.log('📦 Part name:', group.userData.partName);
                    console.log('🎨 Part material:', group.userData.materialName);
                    console.log('📏 Part dimensions:', group.userData.width, 'x', group.userData.height, 'x', group.userData.thickness);
                    
                    // Highlight the clicked part in 3D viewer
                    console.log('🎨 Calling highlightPartIn3DViewer with index:', clickedIndex);
                    highlightPartIn3DViewer(clickedIndex);
                    
                    // Highlight corresponding row in parts table
                    console.log('📋 Calling highlightPartInTable with index:', clickedIndex);
                    highlightPartInTable(clickedIndex);
                    
                    // Update info panel
                    const width = group.userData.width || 0;
                    const height = group.userData.height || 0;
                    const thickness = group.userData.thickness || 0;
                    
                    document.getElementById('selectedPartName').textContent = group.userData.partName || 'Unknown';
                    document.getElementById('selectedPartDims').textContent = `W: ${Math.round(width)} × H: ${Math.round(height)} × T: ${Math.round(thickness)} mm`;
                    const volume = (width * height * thickness / 1000000000).toFixed(4);
                    document.getElementById('selectedPartVolume').textContent = `${volume} m³`;
                    
                    console.log('✅ Info panel updated');
                } else {
                    console.warn('⚠️ Could not find group for clicked mesh');
                }
            } else {
                console.log('ℹ️  No part clicked (clicked on empty space)');
            }
            
            console.log('═══════════════════════════════════════════════════════');
            console.log('🖱️  3D VIEWER CLICK DEBUG END');
            console.log('═══════════════════════════════════════════════════════');
        }
        
        // Highlight a part in the 3D viewer by index
        function highlightPartIn3DViewer(partIndex) {
            if (!isAssemblyMode || partIndex < 0 || partIndex >= assemblyMeshes.length) return;
            
            console.log('🎨 Highlighting part in 3D viewer:', partIndex);
            
            // Reset all parts to original appearance
            assemblyMeshes.forEach((group, idx) => {
                const mesh = group.children[0];
                if (mesh && mesh.material) {
                    const originalMaterial = group.userData.originalMaterial;
                    if (originalMaterial) {
                        mesh.material.color.setHex(originalMaterial.color);
                        mesh.material.opacity = originalMaterial.opacity;
                        mesh.material.transparent = originalMaterial.transparent;
                        mesh.material.map = originalMaterial.map || null;
                    } else {
                        mesh.material.color.setHex(0xcccccc);
                        mesh.material.opacity = 0.85;
                        mesh.material.transparent = true;
                    }
                    mesh.material.emissive.setHex(0x000000);
                    mesh.material.emissiveIntensity = 0;
                    mesh.material.needsUpdate = true;
                }
                
                const wireframe = group.children[1];
                if (wireframe && wireframe.material) {
                    const originalEdgeColor = group.userData.originalEdgeColor || 0x666666;
                    wireframe.material.color.setHex(originalEdgeColor);
                    wireframe.material.linewidth = 1;
                    wireframe.material.needsUpdate = true;
                }
            });
            
            // Highlight the selected part
            const group = assemblyMeshes[partIndex];
            const mesh = group.children[0];
            const wireframe = group.children[1];
            
            if (mesh && mesh.material) {
                mesh.material.emissive.setHex(0x66FF66);
                mesh.material.emissiveIntensity = 0.8;
                
                if (!mesh.material.map) {
                    const currentColor = mesh.material.color.getHex();
                    const r = Math.min(255, ((currentColor >> 16) & 0xFF) + 30);
                    const g = Math.min(255, ((currentColor >> 8) & 0xFF) + 30);
                    const b = Math.min(255, (currentColor & 0xFF) + 30);
                    mesh.material.color.setRGB(r/255, g/255, b/255);
                }
                mesh.material.needsUpdate = true;
            }
            
            if (wireframe && wireframe.material) {
                wireframe.material.color.setHex(0x00FF00);
                wireframe.material.linewidth = 3;
                wireframe.material.needsUpdate = true;
            }
            
            renderOnce();
        }
        
        // Highlight corresponding row in parts table
        function highlightPartInTable(partIndex) {
            console.log('═══════════════════════════════════════════════════════');
            console.log('📋 HIGHLIGHT PART IN TABLE - DEBUG START');
            console.log('═══════════════════════════════════════════════════════');
            console.log('🔢 Requested partIndex:', partIndex);
            
            const tbody = document.getElementById('partsTableBody');
            if (!tbody) {
                console.warn('⚠️ Parts table body not found');
                return;
            }
            
            const rows = tbody.querySelectorAll('tr');
            console.log('📊 Total rows in table:', rows.length);
            
            // Log all row indices for debugging
            console.log('📋 All row data-part-index values:');
            rows.forEach((row, idx) => {
                const storedIndex = row.getAttribute('data-part-index');
                console.log(`  Row ${idx}: data-part-index="${storedIndex}"`);
            });
            
            // Remove highlight and checkmark from all rows
            rows.forEach(row => {
                row.classList.remove('selected');
                // Remove any existing checkmark
                const existingCheck = row.querySelector('.selection-indicator');
                if (existingCheck) {
                    existingCheck.remove();
                }
                // Reset row styling
                row.style.background = '';
                row.style.borderLeft = '';
                row.style.boxShadow = '';
            });
            
            // Find the row with matching data-part-index
            let targetRow = null;
            let targetRowIndex = -1;
            
            for (let i = 0; i < rows.length; i++) {
                const storedIndex = parseInt(rows[i].getAttribute('data-part-index'));
                if (storedIndex === partIndex) {
                    targetRow = rows[i];
                    targetRowIndex = i;
                    break;
                }
            }
            
            if (targetRow) {
                console.log('✅ Found matching row at visual index:', targetRowIndex);
                console.log('   Row data-part-index:', targetRow.getAttribute('data-part-index'));
                
                targetRow.classList.add('selected');
                
                // Add visual styling directly
                targetRow.style.background = '#e0f2fe';
                targetRow.style.borderLeft = '4px solid #0284c7';
                targetRow.style.boxShadow = '0 0 0 1px #0284c7 inset';
                
                // Add checkmark icon at the end of the row
                const lastCell = targetRow.cells[targetRow.cells.length - 1];
                if (lastCell) {
                    const checkIcon = document.createElement('span');
                    checkIcon.className = 'selection-indicator';
                    checkIcon.style.cssText = 'display: inline-block; margin-left: 8px; color: #0284c7; vertical-align: middle;';
                    checkIcon.innerHTML = `
                        <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="3" stroke-linecap="round" stroke-linejoin="round">
                            <polyline points="20 6 9 17 4 12"></polyline>
                        </svg>
                    `;
                    lastCell.appendChild(checkIcon);
                    console.log('✅ Added checkmark icon to row');
                }
                
                // Scroll the row into view
                targetRow.scrollIntoView({ behavior: 'smooth', block: 'center' });
                
                console.log('✅ Successfully highlighted row with checkmark');
            } else {
                console.error('❌ NO MATCHING ROW FOUND!');
                console.error('   Searched for partIndex:', partIndex);
                console.error('   Available indices:', Array.from(rows).map(r => r.getAttribute('data-part-index')));
            }
            
            console.log('═══════════════════════════════════════════════════════');
            console.log('📋 HIGHLIGHT PART IN TABLE - DEBUG END');
            console.log('═══════════════════════════════════════════════════════');
        }
        
        function selectPart(row, name, width, height, thickness, partIndex) {
            // Auto-turn on 3D viewer when clicking a part
            if (!viewer3DActive) {
                toggle3DViewer();
            } else {
                // Reset auto-off timer on interaction
                resetAutoOffTimer();
            }
            
            // Highlight UI Row
            document.querySelectorAll('#partsTableBody tr').forEach(r => r.classList.remove('selected'));
            row.classList.add('selected');
            
            // Update Info Panel
            document.getElementById('selectedPartName').textContent = name;
            document.getElementById('selectedPartDims').textContent = `W: ${Math.round(width)} × H: ${Math.round(height)} × T: ${Math.round(thickness)} mm`;
            const volume = (width * height * thickness / 1000000000).toFixed(4);
            document.getElementById('selectedPartVolume').textContent = `${volume} m³`;
            
            if (isAssemblyMode) {
                // ASSEMBLY MODE: Highlight by INDEX not name (handles unnamed/duplicate names)
                console.log('=== ASSEMBLY SELECTION DEBUG START ===');
                console.log('🔍 Selected part name:', name);
                console.log('🔢 Selected part index:', partIndex);
                console.log('📊 Total assembly meshes:', assemblyMeshes.length);
                console.log('🎯 isAssemblyMode:', isAssemblyMode);
                
                // Log all available part names for comparison
                console.log('📋 All part names in assembly:');
                assemblyMeshes.forEach((group, idx) => {
                    console.log(`  [${idx}] "${group.userData.partName}" (material: ${group.userData.materialName})`);
                });
                
                // Reset all components to their ORIGINAL material appearance
                console.log('🔄 Resetting all meshes to original appearance...');
                assemblyMeshes.forEach((group, idx) => {
                    const mesh = group.children[0];
                    if (mesh && mesh.material) {
                        // Restore original material properties from userData
                        const originalMaterial = group.userData.originalMaterial;
                        if (originalMaterial) {
                            mesh.material.color.setHex(originalMaterial.color);
                            mesh.material.opacity = originalMaterial.opacity;
                            mesh.material.transparent = originalMaterial.transparent;
                            mesh.material.map = originalMaterial.map || null;
                        } else {
                            console.warn(`⚠️ Mesh ${idx} has no originalMaterial stored!`);
                            // Fallback if no original material stored
                            mesh.material.color.setHex(0xcccccc);
                            mesh.material.opacity = 0.85;
                            mesh.material.transparent = true;
                        }
                        mesh.material.emissive.setHex(0x000000);
                        mesh.material.emissiveIntensity = 0;
                        mesh.material.needsUpdate = true;
                    }
                    
                    // Reset edge/wireframe color to original
                    const wireframe = group.children[1];
                    if (wireframe && wireframe.material) {
                        const originalEdgeColor = group.userData.originalEdgeColor || 0x666666;
                        wireframe.material.color.setHex(originalEdgeColor);
                        wireframe.material.linewidth = 1;
                        wireframe.material.needsUpdate = true;
                    }
                });
                
                // Highlight ALL matching components (for multiple instances)
                console.log('✨ Starting highlight process...');
                let highlightCount = 0;
                
                // Use INDEX-based matching if provided, otherwise fall back to name matching
                if (typeof partIndex === 'number' && partIndex >= 0 && partIndex < assemblyMeshes.length) {
                    console.log(`🎯 Using INDEX-based matching: ${partIndex}`);
                    const group = assemblyMeshes[partIndex];
                    const mesh = group.children[0];
                    const wireframe = group.children[1];
                    
                    highlightCount = 1;
                    console.log(`🎨 HIGHLIGHTING mesh at index ${partIndex}:`, {
                        partName: group.userData.partName,
                        hasMesh: !!mesh,
                        hasMaterial: !!(mesh && mesh.material),
                        hasWireframe: !!wireframe,
                        hasWireframeMaterial: !!(wireframe && wireframe.material)
                    });
                    
                    if (mesh && mesh.material) {
                        mesh.material.emissive.setHex(0x66FF66);
                        mesh.material.emissiveIntensity = 0.8;
                        console.log(`  ✓ Set emissive: 0x66FF66, intensity: 0.8`);
                        
                        if (!mesh.material.map) {
                            const currentColor = mesh.material.color.getHex();
                            const r = Math.min(255, ((currentColor >> 16) & 0xFF) + 30);
                            const g = Math.min(255, ((currentColor >> 8) & 0xFF) + 30);
                            const b = Math.min(255, (currentColor & 0xFF) + 30);
                            mesh.material.color.setRGB(r/255, g/255, b/255);
                            console.log(`  ✓ Brightened color to: ${mesh.material.color.getHex().toString(16)}`);
                        }
                        mesh.material.needsUpdate = true;
                    }
                    
                    if (wireframe && wireframe.material) {
                        wireframe.material.color.setHex(0x00FF00);
                        wireframe.material.linewidth = 3;
                        wireframe.material.needsUpdate = true;
                        console.log(`  ✓ Set wireframe: 0x00FF00, linewidth: 3`);
                    }
                } else {
                    // Fallback to NAME-based matching
                    console.log(`📝 Using NAME-based matching: "${name}"`);
                    assemblyMeshes.forEach((group, idx) => {
                        const partName = group.userData.partName;
                        const matches = partName === name;
                        
                        if (idx < 3 || matches) {
                            console.log(`  Mesh ${idx}: "${partName}" === "${name}" ? ${matches}`);
                        }
                        
                        if (matches) {
                            highlightCount++;
                            const mesh = group.children[0];
                            const wireframe = group.children[1];
                            
                            console.log(`🎨 HIGHLIGHTING mesh ${highlightCount}:`, {
                                index: idx,
                                partName: partName,
                                hasMesh: !!mesh,
                                hasMaterial: !!(mesh && mesh.material),
                                hasWireframe: !!wireframe,
                                hasWireframeMaterial: !!(wireframe && wireframe.material),
                                hasTexture: mesh && mesh.material ? mesh.material.map !== null : 'N/A',
                                currentColor: mesh && mesh.material ? mesh.material.color.getHex().toString(16) : 'N/A',
                                currentOpacity: mesh && mesh.material ? mesh.material.opacity : 'N/A'
                            });
                            
                            if (mesh && mesh.material) {
                                mesh.material.emissive.setHex(0x66FF66);
                                mesh.material.emissiveIntensity = 0.8;
                                console.log(`  ✓ Set emissive: 0x66FF66, intensity: 0.8`);
                                
                                if (!mesh.material.map) {
                                    const currentColor = mesh.material.color.getHex();
                                    const r = Math.min(255, ((currentColor >> 16) & 0xFF) + 30);
                                    const g = Math.min(255, ((currentColor >> 8) & 0xFF) + 30);
                                    const b = Math.min(255, (currentColor & 0xFF) + 30);
                                    mesh.material.color.setRGB(r/255, g/255, b/255);
                                    console.log(`  ✓ Brightened color to: ${mesh.material.color.getHex().toString(16)}`);
                                }
                                
                                mesh.material.needsUpdate = true;
                            } else {
                                console.error(`  ✗ Mesh or material missing!`);
                            }
                            
                            if (wireframe && wireframe.material) {
                                wireframe.material.color.setHex(0x00FF00);
                                wireframe.material.linewidth = 3;
                                wireframe.material.needsUpdate = true;
                                console.log(`  ✓ Set wireframe: 0x00FF00, linewidth: 3`);
                            } else {
                                console.error(`  ✗ Wireframe or wireframe material missing!`);
                            }
                        }
                    });
                }
                
                console.log(`✅ Highlighted ${highlightCount} instances`);
                if (highlightCount === 0) {
                    console.error('❌ NO INSTANCES HIGHLIGHTED!');
                    console.error('🔍 Searched for:', name);
                    console.error('📋 Available names:', assemblyMeshes.map(g => g.userData.partName));
                }
                console.log('=== ASSEMBLY SELECTION DEBUG END ===');
                renderOnce();
            } else {
                // FALLBACK: Single Part Mode
                const rowIndex = Array.from(row.parentElement.children).indexOf(row);
                currentComponentIndex = rowIndex;
                
                document.getElementById('canvasPlaceholder').style.display = 'none';
                document.getElementById('parts3DCanvas').style.display = 'block';
                
                if (dimensionGroup && canvas3DCurrentMesh) {
                    canvas3DCurrentMesh.remove(dimensionGroup);
                    dimensionGroup = null;
                }
                
                disposeCurrentMesh();
                
                const geomKey = `${width}_${height}_${thickness}`;
                let geometry = geometryCache[geomKey];
                if (!geometry) {
                    geometry = new THREE.BoxGeometry(width, thickness, height);
                    geometryCache[geomKey] = geometry;
                }
                
                const materialColor = textureMode ? 0xFFFFFF : 0x2323FF;
                const material = new THREE.MeshPhongMaterial({ 
                    color: materialColor, 
                    transparent: true, 
                    opacity: 0.8,
                    side: THREE.DoubleSide
                });
                canvas3DCurrentMesh = new THREE.Mesh(geometry, material);
                
                const edges = new THREE.EdgesGeometry(geometry);
                const lineMaterial = new THREE.LineBasicMaterial({ color: 0x000000, linewidth: 2 });
                const wireframe = new THREE.LineSegments(edges, lineMaterial);
                canvas3DCurrentMesh.add(wireframe);
                
                canvas3DScene.add(canvas3DCurrentMesh);
                
                const maxDim = Math.max(width, height, thickness);
                canvas3DCamera.position.set(maxDim * 1.5, maxDim * 1.2, maxDim * 1.5);
                canvas3DCamera.lookAt(0, 0, 0);
                if (orbitControls) orbitControls.target.set(0, 0, 0);
                
                if (dimensionsVisible) {
                    toggleDimensions();
                    toggleDimensions();
                }
                
                if (textureMode) {
                    loadTextureForCurrentComponent();
                }
                
                const container = document.getElementById('parts3DCanvas').parentElement;
                canvas3DRenderer.setSize(container.clientWidth, container.clientHeight);
            }
            
            renderOnce();
        }
        
        let animationId = null;
        
        function updateDimensionTextScale() {
            // Dimension text now has fixed size, no auto-scaling
        }
        
        function animate3DCanvas() {
            if (!viewer3DActive || !rotationEnabled) {
                return;
            }
            animationId = requestAnimationFrame(animate3DCanvas);
            if (orbitControls) orbitControls.update();
            if (canvas3DCurrentMesh) {
                canvas3DCurrentMesh.rotation.y += 0.005;
            }
            updateDimensionTextScale();
            if (canvas3DRenderer && canvas3DScene && canvas3DCamera) {
                canvas3DRenderer.render(canvas3DScene, canvas3DCamera);
            }
        }
        
        window.addEventListener('load', () => {
            init3DCanvas();
            if (typeof callRuby === 'function') callRuby('ready');
        });
        
        window.addEventListener('resize', () => {
            const canvas = document.getElementById('parts3DCanvas');
            const container = canvas.parentElement;
            canvas3DCamera.aspect = container.clientWidth / container.clientHeight;
            canvas3DCamera.updateProjectionMatrix();
            canvas3DRenderer.setSize(container.clientWidth, container.clientHeight);
        });
    </script>
    <script src="app.js"></script>
    <script src="unit_debug.js"></script>
    <script src="diagrams_report.js?v=20250131_OFFCUTS_FIX"></script>
    <script src="card_visualizations.js"></script>
    <script src="resizer_fix.js"></script>
    <script src="table_customization.js"></script>
    <script src="export_validator.js"></script>
    <script>
        let currentReportData = null;

        function showTab(tabName) {
            document.querySelectorAll('.tab-content').forEach(tab => tab.classList.remove('active'));
            document.querySelectorAll('.tabs .tab-button').forEach(btn => btn.classList.remove('active'));
            
            // Configuration tab specific action buttons
            const configActionButtons = ['generateCutListButton', 'refreshSelectionButton', 'cancelButton'];
            // Report tab specific action buttons
            const reportActionButtons = ['refreshReportButton', 'exportCsvButton', 'exportPdfButton', 'exportHtmlButton', 'copyMarkdownButton', 'exportDrawingsButton'];

            configActionButtons.forEach(id => {
                const btn = document.getElementById(id);
                if (btn) btn.style.display = (tabName === 'config') ? 'inline-flex' : 'none';
            });
            reportActionButtons.forEach(id => {
                const btn = document.getElementById(id);
                if (btn) btn.style.display = (tabName === 'report') ? 'inline-flex' : 'none';
            });
            
            if (tabName === 'config') {
                document.getElementById('configTab').classList.add('active');
            } else if (tabName === 'report') {
                document.getElementById('reportTabContent').classList.add('active');
            } else if (tabName === 'dashboard') {
                document.getElementById('dashboardTabContent').classList.add('active');
                // Render dashboard when tab is shown
                if (typeof renderDashboard === 'function') {
                    renderDashboard();
                }
            }
            document.querySelector(`.tabs [onclick="showTab('${tabName}')"]`).classList.add('active');
        }

        function showReportTab(data) {
            console.log('showReportTab called with data:', data);
            
            document.getElementById('reportTab').disabled = false;
            document.getElementById('dashboardTab').disabled = false; // Enable dashboard tab
            currentReportData = data;
            
            console.log('currentReportData set to:', currentReportData);
            
            // Ensure data structure is correct
            if (data && data.diagrams && data.report) {
                g_boardsData = data.diagrams;
                g_reportData = data.report;
                window.originalComponents = data.original_components || [];
                window.hierarchyTree = data.hierarchy_tree || [];
                window.assemblyData = data.assembly_data || null;
                
                console.log('Report data loaded:', g_reportData);
                console.log('Boards data loaded:', g_boardsData);
                console.log('Assembly data loaded:', window.assemblyData);
                
                // ✅ CRITICAL FIX: Extract settings from report data and apply to global variables
                if (g_reportData && g_reportData.summary) {
                    console.log('═══════════════════════════════════════════════════════════');
                    console.log('🔧 APPLYING SETTINGS FROM REPORT DATA');
                    console.log('═══════════════════════════════════════════════════════════');
                    console.log('Settings from Ruby:', g_reportData.summary);
                    
                    window.currentUnits = g_reportData.summary.units || 'mm';
                    window.reportUnits = g_reportData.summary.units || 'mm';
                    window.currentPrecision = g_reportData.summary.precision ?? 1;
                    window.currentAreaUnits = g_reportData.summary.area_units || 'm2';
                    window.defaultCurrency = g_reportData.summary.currency || 'USD';
                    
                    console.log('✅ Global variables updated:');
                    console.log('  - window.currentUnits:', window.currentUnits);
                    console.log('  - window.reportUnits:', window.reportUnits);
                    console.log('  - window.currentPrecision:', window.currentPrecision);
                    console.log('  - window.currentAreaUnits:', window.currentAreaUnits);
                    console.log('  - window.defaultCurrency:', window.defaultCurrency);
                    console.log('═══════════════════════════════════════════════════════════');
                    
                    // ✅ NEW: Update config tab headers with new settings
                    if (typeof updateConfigTabHeaders === 'function') {
                        updateConfigTabHeaders();
                    }
                } else {
                    console.error('⚠️ WARNING: g_reportData.summary is missing!');
                }
                
                // Render with delay to ensure DOM is ready
                setTimeout(() => {
                    if (typeof renderDiagrams === 'function') {
                        console.log('Calling renderDiagrams');
                        renderDiagrams();
                    }
                    if (typeof renderReport === 'function') {
                        console.log('Calling renderReport');
                        renderReport();
                    }
                    
                    // Render assembly views if data is available
                    if (window.assemblyData && window.assemblyData.views && typeof renderAssemblyViews === 'function') {
                        console.log('Calling renderAssemblyViews');
                        renderAssemblyViews(window.assemblyData);
                    }
                    
                    // Reinitialize table customization after report is rendered
                    setTimeout(() => {
                        if (typeof reinitializeTableCustomization === 'function') {
                            reinitializeTableCustomization();
                        }
                    }, 300);
                }, 100);
                
                showTab('report');
                
                // Initialize export button event listeners only once
                initializeExportButtons();
                
                // Re-initialize resizer after showing report tab
                setTimeout(() => {
                    resizerInitialized = false;
                    initResizer();
                }, 200);
            } else {
                console.error('Invalid data structure received:', data);
                alert('Error: Invalid report data received. Please try generating the report again.');
            }
        }
        
        let exportButtonsInitialized = false;
        
        function initializeExportButtons() {
            if (exportButtonsInitialized) return;
            
            const printBtn = document.getElementById('printButton');
            const exportCsvBtn = document.getElementById('exportCsvButton');
            const exportHtmlBtn = document.getElementById('exportHtmlButton');
            
            if (printBtn) {
                printBtn.addEventListener('click', (e) => {
                    e.preventDefault();
                    e.stopPropagation();
                    exportToPDF();
                });
            }
            
            if (exportCsvBtn) {
                exportCsvBtn.addEventListener('click', (e) => {
                    e.preventDefault();
                    e.stopPropagation();
                    if (currentReportData && currentReportData.report) {
                        callRuby('export_csv', JSON.stringify(currentReportData.report));
                    } else {
                        alert('No report data available for export.');
                    }
                });
            }
            
            const exportPdfBtn = document.getElementById('exportPdfButton');
            if (exportPdfBtn) {
                exportPdfBtn.addEventListener('click', (e) => {
                    e.preventDefault();
                    e.stopPropagation();
                    exportToPDF();
                });
            }
            
            if (exportHtmlBtn) {
                exportHtmlBtn.addEventListener('click', (e) => {
                    e.preventDefault();
                    e.stopPropagation();
                    if (typeof exportInteractiveHTML === 'function') {
                        exportInteractiveHTML();
                    } else {
                        alert('HTML export feature is not available.');
                    }
                });
            }
            
            const copyMarkdownBtn = document.getElementById('copyMarkdownButton');
            if (copyMarkdownBtn) {
                copyMarkdownBtn.addEventListener('click', (e) => {
                    e.preventDefault();
                    e.stopPropagation();
                    copyFullReportAsMarkdown();
                });
            }
            
            exportButtonsInitialized = true;
        }
        
        function exportToPDF() {
            // Call showPDFPreview which triggers Ruby PDF export with ReportPdfExporter
            showPDFPreview();
        }

        function showError(message) {
            console.error('Error:', message);
            
            // Create a styled modal for errors
            const modal = document.createElement('div');
            modal.style.cssText = 'position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.6); z-index: 10000; display: flex; align-items: center; justify-content: center; animation: fadeIn 0.2s;';
            
            const dialog = document.createElement('div');
            dialog.style.cssText = 'background: white; padding: 24px; border-radius: 8px; max-width: 600px; width: 90%; box-shadow: 0 8px 32px rgba(0,0,0,0.3); animation: slideIn 0.3s;';
            
            // Format the message with proper line breaks
            const formattedMessage = message.replace(/\\n/g, '<br>').replace(/\n/g, '<br>');
            
            dialog.innerHTML = `
                <div style="display: flex; align-items: flex-start; gap: 16px; margin-bottom: 20px;">
                    <div style="flex-shrink: 0; width: 48px; height: 48px; background: #fee; border-radius: 50%; display: flex; align-items: center; justify-content: center;">
                        <svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="#d73a49" stroke-width="2">
                            <circle cx="12" cy="12" r="10"/>
                            <line x1="12" y1="8" x2="12" y2="12"/>
                            <line x1="12" y1="16" x2="12.01" y2="16"/>
                        </svg>
                    </div>
                    <div style="flex: 1;">
                        <h3 style="margin: 0 0 12px 0; color: #d73a49; font-size: 18px; font-weight: 600;">Action Required</h3>
                        <div style="color: #24292e; line-height: 1.6; font-size: 14px; white-space: pre-wrap;">${formattedMessage}</div>
                    </div>
                </div>
                <div style="text-align: right;">
                    <button onclick="this.closest('[style*=\'position: fixed\']').remove()" style="background: #d73a49; color: white; border: none; padding: 10px 20px; border-radius: 6px; cursor: pointer; font-size: 14px; font-weight: 500; transition: all 0.2s;">Got it</button>
                </div>
                <style>
                    @keyframes fadeIn { from { opacity: 0; } to { opacity: 1; } }
                    @keyframes slideIn { from { transform: translateY(-20px); opacity: 0; } to { transform: translateY(0); opacity: 1; } }
                    button:hover { background: #cb2431 !important; transform: translateY(-1px); box-shadow: 0 2px 8px rgba(0,0,0,0.2); }
                </style>
            `;
            
            modal.appendChild(dialog);
            document.body.appendChild(modal);
            
            // Close on background click
            modal.addEventListener('click', (e) => {
                if (e.target === modal) modal.remove();
            });
            
            // Close on Escape key
            const escHandler = (e) => {
                if (e.key === 'Escape') {
                    modal.remove();
                    document.removeEventListener('keydown', escHandler);
                }
            };
            document.addEventListener('keydown', escHandler);
        }
        
        function showMaterialWarning(validationData) {
            const modal = document.getElementById('materialWarningModal');
            const content = document.getElementById('materialWarningContent');
            
            if (!validationData.errors_by_material) return;
            
            let html = '';
            Object.keys(validationData.errors_by_material).forEach(material => {
                const errors = validationData.errors_by_material[material];
                const thicknessErrors = errors.filter(e => e.issue === 'thickness');
                const sizeErrors = errors.filter(e => e.issue !== 'thickness');
                
                html += `<div style="margin-bottom: 20px; padding: 16px; background: #f8fafc; border-radius: 6px; border-left: 3px solid #ff9800;">`;
                html += `<h4 style="margin: 0 0 12px 0; color: #24292e; font-size: 16px; font-weight: 600;">📋 ${material}</h4>`;
                
                if (thicknessErrors.length > 0) {
                    html += `<div style="margin-bottom: 12px;">`;
                    html += `<p style="margin: 0 0 8px 0; font-weight: 600; color: #656d76; font-size: 13px;">Thickness Mismatch:</p>`;
                    html += `<ul style="margin: 0; padding-left: 20px; color: #24292e; font-size: 14px;">`;
                    thicknessErrors.forEach(err => {
                        html += `<li style="margin: 4px 0;">${err.component}: <span style="color: #d73a49; font-weight: 600;">${err.part_value}mm</span> ≠ <span style="color: #0366d6; font-weight: 600;">${err.stock_value}mm</span></li>`;
                    });
                    html += `</ul></div>`;
                    
                    const suggestedThickness = thicknessErrors[0].part_value;
                    html += `<div style="padding: 12px; background: #fff3e0; border-radius: 4px; margin-top: 12px;">`;
                    html += `<p style="margin: 0; font-size: 13px; color: #e65100;"><strong>💡 Quick Fix:</strong> Change '${material}' sheet thickness to <strong>${suggestedThickness}mm</strong></p>`;
                    html += `</div>`;
                }
                
                if (sizeErrors.length > 0) {
                    html += `<div style="margin-top: 12px;">`;
                    html += `<p style="margin: 0 0 8px 0; font-weight: 600; color: #656d76; font-size: 13px;">Size Issues:</p>`;
                    html += `<ul style="margin: 0; padding-left: 20px; color: #24292e; font-size: 14px;">`;
                    sizeErrors.forEach(err => {
                        const issueText = err.issue === 'width' ? 'width' : err.issue === 'height' ? 'height' : 'size';
                        html += `<li style="margin: 4px 0;">${err.component}: ${issueText} <span style="color: #d73a49; font-weight: 600;">${err.part_value}mm</span> > sheet <span style="color: #0366d6; font-weight: 600;">${err.stock_value}mm</span></li>`;
                    });
                    html += `</ul></div>`;
                }
                
                html += `</div>`;
            });
            
            html += `<div style="padding: 12px; background: #e3f2fd; border-radius: 6px; border-left: 3px solid #2196f3;">`;
            html += `<p style="margin: 0; font-size: 13px; color: #1565c0;">✏️ <strong>Next Step:</strong> Update the sheet dimensions in the materials list above and try again.</p>`;
            html += `</div>`;
            
            content.innerHTML = html;
            modal.style.display = 'block';
        }
        
        function closeMaterialWarning() {
            document.getElementById('materialWarningModal').style.display = 'none';
        }
        
        function toggleComponentsList() {
            const list = document.getElementById('componentsList');
            const btn = document.getElementById('componentsToggleBtn');
            const isVisible = list.style.display !== 'none';
            list.style.display = isVisible ? 'none' : 'block';
            btn.querySelector('svg').style.transform = isVisible ? 'rotate(0deg)' : 'rotate(180deg)';
        }
        
        // ✅ NEW: Function to update all Configuration tab table headers with dynamic units
        function updateConfigTabHeaders() {
            const currentUnits = window.currentUnits || 'mm';
            const currentAreaUnitLabel = getAreaUnitLabel ? getAreaUnitLabel() : 'm²';
            
            // Update Components Found table headers
            const componentsTable = document.querySelector('#componentsTableBody').closest('table');
            if (componentsTable) {
                const headers = componentsTable.querySelectorAll('thead th');
                if (headers.length >= 5) {
                    headers[1].textContent = `Width (${currentUnits})`;
                    headers[2].textContent = `Height (${currentUnits})`;
                    headers[3].textContent = `Thickness (${currentUnits})`;
                }
            }
            
            // Update Parts Preview table headers
            const partsTable = document.querySelector('#partsTableBody').closest('table');
            if (partsTable) {
                const headers = partsTable.querySelectorAll('thead th');
                if (headers.length >= 7) {
                    headers[1].textContent = `Width (${currentUnits})`;
                    headers[2].textContent = `Height (${currentUnits})`;
                    headers[3].textContent = `Thickness (${currentUnits})`;
                    headers[6].textContent = `Area (${currentAreaUnitLabel})`;
                }
            }
            
            // Update Stock Materials table headers
            const materialsTable = document.getElementById('materialsTable');
            if (materialsTable) {
                const headers = materialsTable.querySelectorAll('thead th');
                if (headers.length >= 6) {
                    headers[1].textContent = `Width (${currentUnits})`;
                    headers[2].textContent = `Height (${currentUnits})`;
                    headers[3].textContent = `Thickness (${currentUnits})`;
                }
            }
            
            console.log(`✅ Config tab headers updated to: ${currentUnits}, ${currentAreaUnitLabel}`);
        }
        
        function updateComponentsList(originalComponents) {
            const tbody = document.getElementById('componentsTableBody');
            const count = document.getElementById('totalComponentsCount');
            const reportPrecision = window.currentPrecision ?? 1;
            
            if (!originalComponents || originalComponents.length === 0) {
                tbody.innerHTML = '<tr><td colspan="5" style="padding: 16px; text-align: center; color: #656d76;">No components found</td></tr>';
                count.textContent = '0';
                return;
            }
            
            count.textContent = originalComponents.length;
            let html = '';
            originalComponents.forEach(comp => {
                const width = (comp.width || 0) / (window.unitFactors[window.currentUnits || 'mm'] || 1);
                const height = (comp.height || 0) / (window.unitFactors[window.currentUnits || 'mm'] || 1);
                const thickness = (comp.depth || comp.thickness || 0) / (window.unitFactors[window.currentUnits || 'mm'] || 1);
                
                html += `<tr style="border-bottom: 1px solid #e1e5e9;">
                    <td style="padding: 8px;">${comp.name || 'Unnamed'}</td>
                    <td style="padding: 8px; text-align: right;">${formatNumber(width, reportPrecision)}</td>
                    <td style="padding: 8px; text-align: right;">${formatNumber(height, reportPrecision)}</td>
                    <td style="padding: 8px; text-align: right;">${formatNumber(thickness, reportPrecision)}</td>
                    <td style="padding: 8px;">${comp.material || 'No Material'}</td>
                </tr>`;
            });
            tbody.innerHTML = html;
        }
        
        function showProgressOverlay(message) {
            const overlay = document.createElement('div');
            overlay.id = 'progressOverlay';
            overlay.innerHTML = `
                <div style="position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.4); z-index: 9999; display: flex; flex-direction: column; align-items: center; justify-content: center;">
                    <div style="width: 50px; height: 50px; border: 4px solid rgba(255,255,255,0.3); border-top: 4px solid #007cba; border-radius: 50%; animation: spin 1s linear infinite; margin-bottom: 20px;"></div>
                    <div id="progressMessage" style="background: rgba(0,0,0,0.8); color: white; padding: 8px 16px; border-radius: 20px; font-size: 14px; margin-bottom: 10px;">${message}</div>
                    <div id="progressPercent" style="background: rgba(0,0,0,0.8); color: white; padding: 4px 12px; border-radius: 15px; font-size: 12px; margin-bottom: 15px;">0%</div>
                    <button onclick="cancelProcessing()" style="background: #ff4444; color: white; border: none; padding: 8px 16px; border-radius: 20px; font-size: 12px; cursor: pointer;">Cancel</button>
                </div>
                <style>
                    @keyframes spin { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } }
                </style>
            `;
            document.body.appendChild(overlay);
        }
        
        function updateProgressOverlay(message, percentage) {
            const messageEl = document.getElementById('progressMessage');
            const percentEl = document.getElementById('progressPercent');
            
            if (messageEl) messageEl.textContent = message;
            if (percentEl) percentEl.textContent = percentage + '%';
        }
        
        function hideProgressOverlay() {
            const overlay = document.getElementById('progressOverlay');
            if (overlay) overlay.remove();
        }
        
        function cancelProcessing() {
            callRuby('cancel_processing');
            hideProgressOverlay();
        }
        
        function refreshConfiguration() {
            callRuby('refresh_config');
        }
        
        function refreshReport() {
            callRuby('refresh_report');
        }
        
        function refreshReportWithFeedback() {
            // Clear cached nesting results to force recalculation with new kerf
            if (typeof g_boardsData !== 'undefined') {
                callRuby('clear_nesting_cache');
            }
            refreshReport();
        }
        
        function receiveRefreshedData(data) {
            // Update the configuration with refreshed data
            receiveInitialData(data);
        }
        
        function refreshReportWithCurrentSettings() {
            // Get current settings from the form
            const settings = getCurrentSettings();
            if (settings) {
                // Re-process with current settings
                callRuby('process', JSON.stringify(settings));
            }
        }
        
        function showConfigTab() {
            showTab('config');
        }
        
        let showTreeView = false;
        
        function toggleTreeView() {
            const button = document.getElementById('treeToggle');
            const treeContainer = document.getElementById('treeStructure');
            const searchContainer = document.getElementById('treeSearchContainer');
            
            const isHidden = treeContainer.style.display === 'none' || treeContainer.style.display === '';
            
            if (isHidden) {
                if (typeof renderTreeStructure === 'function') {
                    renderTreeStructure();
                }
                treeContainer.style.display = 'block';
                if (searchContainer) searchContainer.style.display = 'flex';
                button.textContent = 'Hide Component Tree';
            } else {
                treeContainer.style.display = 'none';
                if (searchContainer) searchContainer.style.display = 'none';
                button.textContent = 'Show Component Tree';
            }
        }

        // --- NEW --- Placeholder for copyTableAsMarkdown function.
        // This will be properly implemented in app.js/diagrams_report.js later.
        // This function is now defined in diagrams_report.js and included there.
        // This blank function prevents errors if called before diagrams_report.js loads.
        function copyTableAsMarkdown(tableId) {
            console.log(`Attempting to copy table: ${tableId}`);
            // Actual implementation is in diagrams_report.js
        }
        
        // Function to format area for PDF output where unit is in the header
        function formatAreaForPDF(areaInMm2) {
            const factor = areaFactors[window.currentAreaUnits || 'm2']; // Default to m2 if not set
            const convertedArea = areaInMm2 / factor;
            return formatNumber(convertedArea, currentPrecision); // Use current precision
        }


        // Ensure required globals are initialized
        window.currencySymbols = window.currencySymbols || {
            'USD': '$', 'EUR': '€', 'GBP': '£', 'JPY': '¥', 'CAD': '$', 'AUD': '$',
            'CHF': 'CHF', 'CNY': '¥', 'SEK': 'kr', 'NZD': '$', 'SAR': 'SAR', 'AED': 'د.إ'
        };
        window.currentUnits = window.currentUnits || 'mm';
        window.currentPrecision = window.currentPrecision ?? 1;
        window.currentAreaUnits = window.currentAreaUnits || 'm2';
        window.areaFactors = window.areaFactors || {
            'mm2': 1, 'cm2': 100, 'm2': 1000000, 'in2': 645.16, 'ft2': 92903.04
        };
        window.unitFactors = window.unitFactors || {
            'mm': 1, 'cm': 10, 'm': 1000, 'in': 25.4, 'ft': 304.8
        };
        window.defaultCurrency = window.defaultCurrency || 'USD';

        // Initialize when DOM is loaded
        document.addEventListener('DOMContentLoaded', () => {

            const modal = document.getElementById('partModal');
            const closeBtns = document.querySelectorAll('#partModal .close');
            
            closeBtns.forEach(btn => {
                btn.addEventListener('click', () => {
                    modal.style.display = 'none';
                });
            });
            
            window.addEventListener('click', (e) => {
                if (e.target === modal) {
                    modal.style.display = 'none';
                }
            });

            // Initialize resizer with a delay to ensure DOM is ready
            setTimeout(() => {
                initResizer();
            }, 100);
            
            // ✅ NEW: Update config tab headers with current units
            setTimeout(() => {
                if (typeof updateConfigTabHeaders === 'function') {
                    updateConfigTabHeaders();
                }
            }, 200);
            
            if (typeof callRuby === 'function') {
                callRuby('ready');
            }
            
            // REMOVED: "Used Only" toggle initialization - Stock Materials table now always shows only used materials
            // The displayMaterials() function in app.js now always filters to show only used materials
        });

        function generateSummaryTableHTML(reportData) {
            console.log('generateSummaryTableHTML called with:', reportData);
            if (!reportData || !reportData.summary) {
                console.log('No summary data found');
                return '<thead><tr><th>Project Metric</th><th>Value</th></tr></thead><tbody><tr><td colspan="2">No project data available</td></tr></tbody>';
            }
            
            const summary = reportData.summary;
            const currency = summary.currency || window.defaultCurrency || 'USD';
            const currencySymbol = window.currencySymbols[currency] || currency;
            const reportPrecision = window.currentPrecision ?? 1;
            
            let html = `<thead><tr><th>Project Metric</th><th>Value</th></tr></thead><tbody>`;
            
            if (summary.project_name && summary.project_name !== 'Untitled Project') {
                html += `<tr><td>Project Name</td><td><strong>${summary.project_name}</strong></td></tr>`;
            }
            if (summary.client_name) {
                html += `<tr><td>Client</td><td><strong>${summary.client_name}</strong></td></tr>`;
            }
            if (summary.prepared_by) {
                html += `<tr><td>Prepared by</td><td><strong>${summary.prepared_by}</strong></td></tr>`;
            }
            
            html += `
                <tr><td>Total Parts</td><td>${summary.total_parts_instances || 0}</td></tr>
                <tr><td>Unique Components</td><td>${summary.total_unique_part_types || 0}</td></tr>
                <tr><td>Material Sheets</td><td>${summary.total_boards || 0}</td></tr>
                <tr><td>Kerf Width</td><td>${summary.kerf_width || '3.0mm'}</td></tr>
                <tr><td>Material Efficiency</td><td>${formatNumber(summary.overall_efficiency || 0, reportPrecision)}%</td></tr>
                <tr><td>Total Waste Area</td><td>${summary.total_waste_area_absolute || '0 m²'}</td></tr>
                <tr><td class="total-highlight">Total Cost</td><td class="total-highlight">${currencySymbol}${formatNumber(summary.total_project_cost || 0, 2)}</td></tr>
            </tbody>`;
            
            return html;
        }
        
        function generateUniquePartsTableHTML(reportData) {
            console.log('generateUniquePartsTableHTML called with:', reportData);
            if (!reportData || !reportData.unique_part_types || reportData.unique_part_types.length === 0) {
                console.log('No unique_part_types found');
                return '<thead><tr><th>Part Name</th><th>Width</th><th>Height</th><th>Thickness</th><th>Material</th><th>Grain</th><th>Qty</th><th>Area</th></tr></thead><tbody><tr><td colspan="8">No part specifications available</td></tr></tbody>';
            }
            
            const reportUnits = window.currentUnits || 'mm';
            const reportPrecision = window.currentPrecision ?? 1;
            const currentAreaUnitLabel = getAreaUnitLabel();
            
            let html = `<thead><tr><th>Part Name</th><th>Width (${reportUnits})</th><th>Height (${reportUnits})</th><th>Thickness (${reportUnits})</th><th>Material</th><th>Grain</th><th>Qty</th><th>Area (${currentAreaUnitLabel})</th></tr></thead><tbody>`;
            
            reportData.unique_part_types.forEach(part_type => {
                const width = part_type.width / window.unitFactors[reportUnits];
                const height = part_type.height / window.unitFactors[reportUnits];
                const thickness = part_type.thickness / window.unitFactors[reportUnits];
                
                html += `<tr>
                    <td>${part_type.name}</td>
                    <td>${formatNumber(width, reportPrecision)}</td>
                    <td>${formatNumber(height, reportPrecision)}</td>
                    <td>${formatNumber(thickness, reportPrecision)}</td>
                    <td>${part_type.material}</td>
                    <td>${part_type.grain_direction || 'Any'}</td>
                    <td class="total-highlight">${part_type.total_quantity}</td>
                    <td>${getAreaDisplay(part_type.total_area)}</td>
                </tr>`;
            });
            
            html += `</tbody>`;
            return html;
        }
        
        function generateBoardsSummaryHTML(boardsData) {
            if (!boardsData || boardsData.length === 0) return '<table><thead><tr><th>Sheet</th><th>Material</th><th>Dimensions</th><th>Parts</th><th>Efficiency</th><th>Waste</th></tr></thead><tbody><tr><td colspan="6">No material requirements available</td></tr></tbody></table>';
            
            const reportUnits = window.currentUnits || 'mm';
            const reportPrecision = window.currentPrecision ?? 1;
            
            let html = `<table><thead><tr><th>Sheet</th><th>Material</th><th>Dimensions (${reportUnits})</th><th>Parts Count</th><th>Efficiency</th><th>Waste</th></tr></thead><tbody>`;
            
            boardsData.forEach((board, index) => {
                const width = (board.stock_width || 0) / window.unitFactors[reportUnits];
                const height = (board.stock_height || 0) / window.unitFactors[reportUnits];
                
                html += `<tr>
                    <td>Sheet ${index + 1}</td>
                    <td>${board.material}</td>
                    <td>${formatNumber(width, reportPrecision)} × ${formatNumber(height, reportPrecision)}</td>
                    <td>${board.parts ? board.parts.length : 0}</td>
                    <td>${formatNumber(board.efficiency_percentage, 1)}%</td>
                    <td>${formatNumber(board.waste_percentage, 1)}%</td>
                </tr>`;
            });
            
            html += `</tbody></table>`;
            return html;
        }
        
        function generateDiagramsHTML(boardsData) {
            if (!boardsData || boardsData.length === 0) return '<div style="text-align: center;"><p>No cutting diagrams available</p></div>';
            
            let html = '';
            const diagramsContainer = document.getElementById('diagramsContainer');
            
            if (diagramsContainer) {
                const canvases = diagramsContainer.querySelectorAll('canvas');
                
                boardsData.forEach((board, index) => {
                    if (index < canvases.length) {
                        try {
                            const canvas = canvases[index];
                            const imageData = canvas.toDataURL('image/png', 0.8);
                            
                            html += `<div class="diagram-section">
                                <h3>Sheet ${index + 1}: ${board.material}</h3>
                                <div class="diagram-container">
                                    <img src="${imageData}" alt="Cutting diagram for ${board.material}" class="diagram-image">
                                </div>
                                <p class="diagram-info">Efficiency: ${formatNumber(board.efficiency_percentage, 1)}% | Waste: ${formatNumber(board.waste_percentage, 1)}%</p>
                            </div>`;
                        } catch (error) {
                            html += `<div class="diagram-section">
                                <h3>Sheet ${index + 1}: ${board.material}</h3>
                                <div class="diagram-placeholder">
                                    <p>Diagram Export Not Available</p>
                                    <p>Size: ${formatNumber((board.stock_width || 0) / window.unitFactors[window.currentUnits || 'mm'], window.currentPrecision ?? 1)} × ${formatNumber((board.stock_height || 0) / window.unitFactors[window.currentUnits || 'mm'], window.currentPrecision ?? 1)} ${window.currentUnits || 'mm'}</p>
                                </div>
                                <p class="diagram-info">Efficiency: ${formatNumber(board.efficiency_percentage, 1)}% | Waste: ${formatNumber(board.waste_percentage, 1)}%</p>
                            </div>`;
                        }
                    }
                });
            }
            
            return html;
        }
        
        function generateDetailedPartsTableHTML(reportData, boardsData) {
            let allParts = [];
            
            // Use parts_placed from reportData if available
            if (reportData && reportData.parts_placed) {
                allParts = reportData.parts_placed;
            } else if (boardsData && boardsData.length > 0) {
                // Fallback to boardsData
                boardsData.forEach((board, boardIndex) => {
                    if (board.parts) {
                        board.parts.forEach(part => {
                            allParts.push({
                                ...part,
                                board_number: boardIndex + 1,
                                board_material: board.material
                            });
                        });
                    }
                });
            }
            
            if (allParts.length === 0) {
                return '<thead><tr><th>Part ID</th><th>Name</th><th>Dimensions</th><th>Material</th><th>Board</th><th>Grain</th><th>Edge Banding</th></tr></thead><tbody><tr><td colspan="7">No detailed parts available</td></tr></tbody>';
            }
            
            const reportUnits = window.currentUnits || 'mm';
            const reportPrecision = window.currentPrecision ?? 1;
            
            let html = `<thead><tr><th>Part ID</th><th>Name</th><th>Dimensions (${reportUnits})</th><th>Material</th><th>Sheet #</th><th>Grain</th><th>Edge Banding</th></tr></thead><tbody>`;
            
            allParts.forEach((part, index) => {
                const width = (part.width || 0) / window.unitFactors[reportUnits];
                const height = (part.height || 0) / window.unitFactors[reportUnits];
                const partId = part.part_unique_id || part.instance_id || `P${index + 1}`;
                
                // Handle edge banding display
                let edgeBandingDisplay = 'None';
                if (part.edge_banding_summary && part.edge_banding_summary.type !== 'None') {
                    const summary = part.edge_banding_summary;
                    edgeBandingDisplay = `${summary.type} (${summary.total_length}mm)`;
                } else if (part.edge_banding && part.edge_banding !== 'None') {
                    edgeBandingDisplay = typeof part.edge_banding === 'object' ? part.edge_banding.type || 'None' : part.edge_banding;
                }
                
                html += `<tr>
                    <td>${escapeHtml(partId)}</td>
                    <td>${escapeHtml(part.name)}</td>
                    <td>${formatNumber(width, reportPrecision)} × ${formatNumber(height, reportPrecision)}</td>
                    <td>${escapeHtml(part.material)}</td>
                    <td>${part.board_number}</td>
                    <td>${escapeHtml(part.grain_direction || 'Any')}</td>
                    <td>${escapeHtml(edgeBandingDisplay)}</td>
                </tr>`;
            });
            
            html += `</tbody>`;
            return html;
        }
        
        function generateSheetInventoryTableHTML(reportData) {
            if (!reportData || !reportData.unique_board_types || reportData.unique_board_types.length === 0) {
                return '<thead><tr><th>Material</th><th>Dimensions</th><th>Count</th><th>Total Area</th><th>Price/Sheet</th><th>Total Cost</th></tr></thead><tbody><tr><td colspan="6">No sheet inventory available</td></tr></tbody>';
            }
            
            const reportUnits = window.currentUnits || 'mm';
            const reportPrecision = window.currentPrecision ?? 1;
            const currentAreaUnitLabel = getAreaUnitLabel();
            const currency = reportData.summary?.currency || window.defaultCurrency || 'USD';
            
            let html = `<thead><tr><th>Material</th><th>Dimensions (${reportUnits})</th><th>Count</th><th>Total Area (${currentAreaUnitLabel})</th><th>Price/Sheet</th><th>Total Cost</th></tr></thead><tbody>`;
            
            reportData.unique_board_types.forEach(board_type => {
                const boardCurrency = board_type.currency || currency;
                const boardSymbol = window.currencySymbols[boardCurrency] || boardCurrency;
                const width = (board_type.stock_width || 0) / window.unitFactors[reportUnits];
                const height = (board_type.stock_height || 0) / window.unitFactors[reportUnits];
                const dimensionsStr = `${formatNumber(width, reportPrecision)} × ${formatNumber(height, reportPrecision)}`;
                
                html += `<tr>
                    <td>${escapeHtml(board_type.material)}</td>
                    <td>${dimensionsStr}</td>
                    <td class="total-highlight">${board_type.count}</td>
                    <td style="text-align:right;">${getAreaDisplay(board_type.total_area)}</td>
                    <td>${boardSymbol}${formatNumber(board_type.price_per_sheet || 0, 2)}</td>
                    <td class="total-highlight">${boardSymbol}${formatNumber(board_type.total_cost || 0, 2)}</td>
                </tr>`;
            });
            
            html += `</tbody>`;
            return html;
        }
        
        function generateCutSequencesHTML(reportData) {
            if (!reportData || !reportData.cut_sequences || reportData.cut_sequences.length === 0) {
                return '<div style="text-align: center; padding: 20px;"><p>No cut sequences available</p></div>';
            }
            
            let html = '';
            reportData.cut_sequences.forEach(board => {
                html += `<div class="board-summary">
                    <h3>Sheet ${board.board_number}: ${escapeHtml(board.material)}</h3>
                    <p><strong>Stock Size:</strong> ${escapeHtml(board.stock_dimensions)}</p>
                    <table>
                        <thead><tr><th>Step</th><th>Operation</th><th>Description</th><th>Measurement</th></tr></thead>
                        <tbody>`;
                
                board.cut_sequence.forEach(step => {
                    html += `<tr>
                        <td>${step.step}</td>
                        <td>${escapeHtml(step.type)}</td>
                        <td>${escapeHtml(step.description)}</td>
                        <td>${escapeHtml(step.measurement)}</td>
                    </tr>`;
                });
                
                html += `</tbody></table></div>`;
            });
            
            return html;
        }
        
        function generateOffcutsTableHTML(reportData) {
            if (!reportData || !reportData.usable_offcuts || reportData.usable_offcuts.length === 0) {
                return '<thead><tr><th>Sheet #</th><th>Material</th><th>Estimated Size</th><th>Area (m²)</th></tr></thead><tbody><tr><td colspan="4">No significant offcuts</td></tr></tbody>';
            }
            
            let html = '<thead><tr><th>Sheet #</th><th>Material</th><th>Estimated Size</th><th>Area (m²)</th></tr></thead><tbody>';
            
            reportData.usable_offcuts.forEach(offcut => {
                html += `<tr>
                    <td>${offcut.board_number}</td>
                    <td>${escapeHtml(offcut.material)}</td>
                    <td>${escapeHtml(offcut.estimated_dimensions)}</td>
                    <td>${offcut.area_m2}</td>
                </tr>`;
            });
            
            html += '</tbody>';
            return html;
        }
        
        function renderCutSequences(reportData) {
            const container = document.getElementById('cutSequenceContainer');
            if (!container || !reportData.cut_sequences) {
                return;
            }
            
            // Render each sheet as its own independent table-with-controls container
            let html = '';
            reportData.cut_sequences.forEach(board => {
                const tableId = `cutSequenceTable_${board.board_number}`;
                html += `
                <div class="table-with-controls">
                    <div class="table-controls">
                        <button class="icon-btn" onclick="openTableCustomization('${tableId}')" title="Customize Table">
                            <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                                <rect x="3" y="3" width="18" height="18" rx="2" ry="2"/>
                                <path d="M9 9h6v6H9z"/>
                                <path d="M9 3v6M15 3v6M21 9H3M21 15H3"/>
                            </svg>
                        </button>
                        <button class="icon-btn" onclick="copyTableAsMarkdown('${tableId}')" title="Copy Markdown">
                            <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                                <rect width="14" height="14" x="8" y="8" rx="2" ry="2"/>
                                <path d="M4 16c-1.1 0-2-.9-2-2V4c0-1.1.9-2 2-2h10c1.1 0 2 .9 2 2"/>
                            </svg>
                        </button>
                    </div>
                    <div class="cut-sequence-board">
                        <h4>Sheet ${board.board_number}: ${board.material}</h4>
                        <p><strong>Stock Size:</strong> ${board.stock_dimensions}</p>
                        <table id="${tableId}" class="cut-sequence-table">
                            <thead><tr><th>Step</th><th>Operation</th><th>Description</th><th>Measurement</th></tr></thead>
                            <tbody>
                                ${board.cut_sequence.map(step => `
                                    <tr>
                                        <td>${step.step}</td>
                                        <td>${step.type}</td>
                                        <td>${step.description}</td>
                                        <td>${step.measurement}</td>
                                    </tr>
                                `).join('')}
                            </tbody>
                        </table>
                    </div>
                </div>`;
            });
            
            container.innerHTML = html;
            
            // After rendering, reinitialize customization so new tables get settings and handles
            if (typeof reinitializeTableCustomization === 'function') {
                reinitializeTableCustomization();
            }
        }
        

        
        function renderOffcutsTable(reportData) {
            const table = document.getElementById('offcutsTable');
            if (!table || !reportData.usable_offcuts) {
                return;
            }
            
            if (reportData.usable_offcuts.length === 0) {
                table.innerHTML = '<thead><tr><th>Sheet #</th><th>Material</th><th>Estimated Size</th><th>Area (m²)</th></tr></thead><tbody><tr><td colspan="4">No significant offcuts</td></tr></tbody>';
                return;
            }
            
            let html = '<thead><tr><th>Sheet #</th><th>Material</th><th>Estimated Size</th><th>Area (m²)</th></tr></thead><tbody>';
            
            reportData.usable_offcuts.forEach(offcut => {
                html += `<tr>
                    <td>${offcut.board_number}</td>
                    <td>${offcut.material}</td>
                    <td>${offcut.estimated_dimensions}</td>
                    <td>${offcut.area_m2}</td>
                </tr>`;
            });
            
            html += '</tbody>';
            table.innerHTML = html;
        }
        
        function generateCostTableHTML(reportData) {
            console.log('generateCostTableHTML called with:', reportData);
            if (!reportData || !reportData.unique_board_types || reportData.unique_board_types.length === 0) {
                console.log('No unique_board_types found');
                return '<thead><tr><th>Material Type</th><th>Sheets Required</th><th>Unit Cost</th><th>Total Cost</th></tr></thead><tbody><tr><td colspan="4">No cost analysis available</td></tr></tbody>';
            }
            
            const currency = reportData.summary?.currency || window.defaultCurrency || 'USD';
            const currencySymbol = window.currencySymbols[currency] || currency;
            
            let html = `<thead><tr><th>Material Type</th><th>Sheets Required</th><th>Unit Cost</th><th>Total Cost</th></tr></thead><tbody>`;
            
            reportData.unique_board_types.forEach(board_type => {
                const boardCurrency = board_type.currency || currency;
                const boardSymbol = window.currencySymbols[boardCurrency] || boardCurrency;
                html += `<tr>
                    <td>${board_type.material}</td>
                    <td>${board_type.count}</td>
                    <td>${boardSymbol}${formatNumber(board_type.price_per_sheet || 0, 2)}</td>
                    <td class="total-highlight">${boardSymbol}${formatNumber(board_type.total_cost || 0, 2)}</td>
                </tr>`;
            });
            
            html += `</tbody>`;
            return html;
        }

        function showPDFPreview() {
            const reportData = currentReportData;
            const boardsData = g_boardsData || [];
            
            if (!reportData || !reportData.report) {
                alert('No report data available. Please generate a report first.');
                return;
            }
            
            const timestamp = new Date().toLocaleString();
            const actualReportData = reportData.report || reportData;

            // Generate ALL required HTML tables from the report data with consistent structure
            const summaryTable = generateSummaryTableHTML(actualReportData);
            const uniquePartsTable = generateUniquePartsTableHTML(actualReportData);
            const sheetInventoryTable = generateSheetInventoryTableHTML(actualReportData);
            const detailedPartsTable = generateDetailedPartsTableHTML(actualReportData, boardsData);
            const costTable = generateCostTableHTML(actualReportData);
            const cutSequencesHTML = generateCutSequencesHTML(actualReportData);
            const offcutsTable = generateOffcutsTableHTML(actualReportData);

            const styleCss = `@page {
    size: A4;
    margin: 20mm;
}

body {
    font-family: 'Inter', sans-serif;
    margin: 0;
    padding: 0;
    background: #ffffff;
    color: #1a1a1a;
    font-size: 11pt;
    line-height: 1.5;
    font-weight: 400;
    max-width: 210mm;
    box-sizing: border-box;
    page-break-inside: avoid;
}

/* PDF Preview specific styles */
@media screen {
    body {
        max-width: 210mm;
        margin: 20px auto;
        padding: 20mm;
        box-shadow: 0 0 20px rgba(0,0,0,0.1);
        min-height: 297mm; /* A4 height */
        background: white;
    }
    
    .page-break {
        page-break-before: always;
        margin-top: 40px;
        padding-top: 20px;
        border-top: 2px dashed #ccc;
    }
    
    .page-break::before {
        content: "Page Break";
        display: block;
        text-align: center;
        color: #999;
        font-size: 10pt;
        margin-bottom: 20px;
    }
}

* {
    box-sizing: border-box;
}

.header {
    text-align: center;
    margin-bottom: 30pt;
    padding-bottom: 15pt;
    border-bottom: 1pt solid #e1e5e9;
}
.header h1 {
    font-size: 24pt;
    font-weight: 600;
    color: #1a1a1a;
    margin: 0 0 6pt 0;
    letter-spacing: -0.02em;
}

.header p {
    font-size: 11pt;
    color: #6b7280;
    margin: 3pt 0;
    font-weight: 400;
}

.controls {
    display: none;
}

@media print {
    .controls, .no-print {
        display: none !important;
    }
}
.section {
    margin-bottom: 25pt;
    page-break-inside: avoid;
    break-inside: avoid;
}

.section:nth-child(n+4) {
    page-break-before: auto;
}

/* Force page breaks for large sections */
.section.large-section {
    page-break-before: always;
}

.section-title, h2 {
    font-size: 16pt;
    font-weight: 600;
    color: #1a1a1a;
    margin: 20pt 0 12pt 0;
    padding: 0;
    border: none;
    background: transparent;
    letter-spacing: -0.01em;
}

.section:first-of-type .section-title {
    margin-top: 0;
}
.tabs {
    display: flex;
    gap: 4px;
    background: #f6f8fa;
    padding: 4px;
    border-radius: 6px;
}
.tab-button {
    background: transparent;
    border: none;
    padding: 8px 16px;
    border-radius: 4px;
    font-size: 14px;
    color: #656d76;
    cursor: pointer;
    transition: all 0.15s;
    display: inline-flex; /* Ensure tab buttons also use flex for potential icon alignment */
    align-items: center;
    justify-content: center;
}
.tab-button:hover {
    background: #ffffff;
    color: #24292e;
}
.tab-button.active {
    background: #ffffff;
    color: #24292e;
    box-shadow: 0 1px 3px rgba(0,0,0,0.12);
}
.tab-button:disabled {
    opacity: 0.5;
    cursor: not-allowed;
}
.tab-content {
    display: none;
    flex: 1;
    overflow: hidden;
}
.tab-content.active {
    display: flex;
    flex-direction: column;
}
.config-container {
    max-width: 900px;
    margin: 0 auto;
    padding: 24px;
    overflow-y: auto;
    flex: 1;
}
.report-header {
    background: #ffffff;
    border-bottom: 1px solid #d0d7de;
    padding: 12px 20px;
    display: flex;
    gap: 12px;
    align-items: center;
    flex-shrink: 0;
}
.icon-btn, .material-icon-btn {
    display: inline-flex;
    align-items: center;
    justify-content: center;
    padding: 8px; /* Standard padding for square icon buttons */
    min-width: 36px; /* Ensure a minimum size */
    height: 36px; /* Ensure a consistent height */
    border-radius: 6px; /* Standard border-radius for buttons */
    cursor: pointer;
    transition: all 0.15s ease;
    border: 1px solid #d0d7de;
    background: #ffffff;
    color: #24292e; /* Default color for icons */
    box-sizing: border-box; /* Include padding and border in element's total width and height */
    white-space: nowrap; /* Prevent text wrapping for combined icon/text buttons */
}
.icon-btn:hover, .material-icon-btn:hover {
    background: #f6f8fa;
    border-color: #8c959f;
    transform: translateY(-1px);
}
.icon-btn:active, .material-icon-btn:active {
    transform: translateY(0);
    transition: all 0.05s ease;
}
.icon-btn svg, .material-icon-btn svg {
    transition: transform 0.15s ease;
    flex-shrink: 0;
    stroke: currentColor; /* Inherit color from parent button */
    stroke-width: 2; /* Standard Lucide stroke-width */
    width: 16px; /* Standard icon size */
    height: 16px; /* Standard icon size */
}
.icon-btn:hover svg, .material-icon-btn:hover svg {
    transform: scale(1.1);
}
.header-controls .action-buttons .tab-button.icon-btn.report-action-btn {
    background: #ffffff; /* Light background */
    color: #24292e; /* Dark icon color */
    border: 1px solid #d0d7de; /* Border to match other light buttons */
    padding: 8px; /* Consistent padding */
    min-width: 36px;
    height: 36px;
    box-shadow: none; /* Remove tab button box shadow if it applies */
}
.header-controls .action-buttons .tab-button.icon-btn.report-action-btn:hover {
    background: #f6f8fa; /* Light grey on hover */
    border-color: #8c959f; /* Darker border on hover */
    transform: translateY(-1px);
}
/* REMOVED: #foldToggle.active styles - "Used Only" toggle button removed */
.visually-hidden {
    position: absolute;
    width: 1px;
    height: 1px;
    margin: -1px;
    padding: 0;
    overflow: hidden;
    clip: rect(0, 0, 0, 0);
    border: 0;
}
table {
    width: 100%;
    border-collapse: collapse;
    margin: 12pt 0;
    font-size: 10pt;
    background: #ffffff;
    border: 1pt solid #e1e5e9;
    page-break-inside: auto;
    break-inside: auto;
}

/* Ensure table headers repeat on new pages */
thead {
    display: table-header-group;
}

tbody {
    display: table-row-group;
}

/* Prevent orphaned table rows */
tr {
    page-break-inside: avoid;
    break-inside: avoid;
}

th {
    background: #f8fafc;
    color: #374151;
    font-weight: 600;
    padding: 8pt 10pt;
    text-align: left;
    border-bottom: 1pt solid #e1e5e9;
    font-size: 9pt;
    text-transform: uppercase;
    letter-spacing: 0.05em;
}

td {
    padding: 8pt 10pt;
    border-bottom: 0.5pt solid #f1f5f9;
    color: #1a1a1a;
    vertical-align: top;
}

tr:nth-child(even) {
    background: #fafbfc;
}

tr:hover {
    background: #f1f5f9;
}
.total-highlight {
    font-weight: 600;
    color: #1a1a1a;
    background: #f0f9ff;
}

.board-summary {
    margin-bottom: 15pt;
    padding: 12pt;
    background: #f8fafc;
    border: 1pt solid #e1e5e9;
    border-radius: 3pt;
}

.board-summary h3 {
    font-size: 12pt;
    font-weight: 600;
    color: #1a1a1a;
    margin: 0 0 8pt 0;
}

.board-summary p {
    margin: 4pt 0;
    font-size: 10pt;
    color: #4b5563;
}

.board-summary strong {
    color: #1a1a1a;
    font-weight: 600;
}

.board-summary ul {
    margin: 6pt 0 6pt 15pt;
    padding: 0;
    font-size: 9pt;
    color: #6b7280;
}

.board-summary li {
    margin: 2pt 0;
    line-height: 1.3;
}

.diagram-section {
    margin-bottom: 20pt;
    page-break-inside: avoid;
    text-align: center;
}

.diagram-section h3 {
    font-size: 12pt;
    font-weight: 600;
    color: #1a1a1a;
    margin: 0 0 8pt 0;
    text-align: center;
}

.diagram-container {
    display: flex;
    justify-content: center;
    margin: 10pt 0;
}

.diagram-image {
    max-width: 100%;
    height: auto;
    border: 1pt solid #e1e5e9;
    border-radius: 3pt;
}

.diagram-placeholder {
    text-align: center;
    margin: 10pt 0;
    border: 1pt solid #e1e5e9;
    border-radius: 3pt;
    padding: 20pt;
    background: #fafbfc;
    color: #6b7280;
    font-size: 10pt;
}

.diagram-placeholder p {
    margin: 3pt 0;
}

.diagram-info {
    text-align: center;
    font-size: 9pt;
    color: #6b7280;
    margin: 6pt 0 0 0;
    font-style: italic;
}

.floating-controls {
    position: fixed;
    right: 20px;
    bottom: 20px;
    display: flex;
    flex-direction: column;
    gap: 10px;
    z-index: 1000;
}

.floating-btn {
    width: 48px;
    height: 48px;
    border-radius: 50%;
    border: 1pt solid #d1d5db;
    background: #ffffff;
    color: #374151;
    cursor: pointer;
    display: flex;
    align-items: center;
    justify-content: center;
    box-shadow: 0 2px 8px rgba(0,0,0,0.15);
    transition: all 0.2s ease;
    font-size: 0;
}

.floating-btn:hover {
    background: #f9fafb;
    transform: translateY(-2px);
    box-shadow: 0 4px 12px rgba(0,0,0,0.2);
}

.export-btn {
    background: #1f2937;
    color: white;
    border-color: #1f2937;
}

.export-btn:hover {
    background: #111827;
}

.floating-btn svg {
    stroke: currentColor;
}

@media print {
    .floating-controls {
        display: none;
    }
    
    .page-break {
        page-break-before: always;
        border: none;
        margin: 0;
        padding: 0;
    }
    
    .page-break::before {
        display: none;
    }
    
    .diagram-section {
        page-break-inside: avoid;
        page-break-after: auto;
    }
    
    .section {
        page-break-inside: avoid;
    }
    
    table {
        page-break-inside: auto;
    }
    
    tr {
        page-break-inside: avoid;
    }
    
    .header {
        page-break-after: avoid;
    }
}
.footer {
    margin-top: 30pt;
    padding-top: 15pt;
    border-top: 1pt solid #e1e5e9;
    text-align: center;
    font-size: 9pt;
    color: #6b7280;
}

.footer p {
    margin: 3pt 0;
}

@media print {
    body {
        font-size: 10pt;
    }
    
    .section {
        page-break-inside: avoid;
    }
    
    table {
        page-break-inside: avoid;
    }
    
    .board-summary {
        page-break-inside: avoid;
    }
}
/* Additional professional styling */
.no-print {
    margin: 15pt 0;
    text-align: center;
    padding: 12pt;
    background: #f8fafc;
    border: 1pt solid #e1e5e9;
    border-radius: 3pt;
}

@media screen {
    body {
        max-width: 800px;
        margin: 20px auto;
        padding: 20px;
        box-shadow: 0 0 20px rgba(0,0,0,0.1);
    }
}
button {
    padding: 8pt 12pt;
    margin: 3pt;
    border: 1pt solid #d1d5db;
    border-radius: 3pt;
    font-size: 10pt;
    background: #ffffff;
    color: #374151;
    cursor: pointer;
    font-family: inherit;
}

button:hover {
    background: #f9fafb;
    border-color: #9ca3af;
}

.print-btn {
    background: #1f2937;
    color: white;
    border-color: #1f2937;
    font-weight: 500;
}

.close-btn {
    background: #f3f4f6;
    color: #374151;
    border-color: #d1d5db;
}
/* Simplified table styling for PDF */
.table-wrapper {
    margin-bottom: 12pt;
    overflow: visible;
}

/* Remove complex interactive elements for PDF */
.table-controls {
    display: none;
}
/* Remove all interactive panel elements for PDF */
.table-customization-panel,
.modal-overlay,
.panel-buttons,
.table-setting-group {
    display: none;
}
.table-with-controls table th {
    position: relative;
    border-right: 1px solid #d0d7de;
}
.column-resize-handle {
    position: absolute;
    top: 0;
    right: -3px;
    width: 6px;
    height: 100%;
    cursor: col-resize;
    background: rgba(0, 124, 186, 0.2);
    border-right: 1px solid rgba(0, 124, 186, 0.4);
    z-index: 10;
    transition: all 0.2s ease;
}
.column-resize-handle:hover {
    background: rgba(0, 124, 186, 0.6);
    border-right: 2px solid #007cba;
    width: 8px;
    right: -4px;
}
.column-resize-handle.resizing {
    background: #007cba;
    border-right: 2px solid #005a87;
    width: 8px;
    right: -4px;
}
.table-with-controls .column-resize-handle {
    opacity: 0.6;
}
.table-with-controls:hover .column-resize-handle {
    opacity: 0.8;
}
.table-with-controls .column-resize-handle:hover {
    opacity: 1;
    transform: scaleX(1.2);
}
.table-with-controls table th:not(:last-child)::after {
    content: '';
    position: absolute;
    top: 10%;
    right: 0;
    width: 1px;
    height: 80%;
    background: rgba(0, 124, 186, 0.15);
    pointer-events: none;
}
.table-with-controls table {
    transition: all 0.2s ease;
}
.table-with-controls th,
.table-with-controls td {
    transition: all 0.2s ease;
}
.table-customization-panel.active + .modal-overlay {
    display: block;
}
.modal-overlay {
    display: none;
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background: rgba(0, 0, 0, 0.3);
    z-index: 999;
}
.report-title {
    display: flex;
    justify-content: space-between;
    align-items: center;
    margin-bottom: 16px;
}
.report-title h2 {
    margin: 0;
}
.color-input::-webkit-color-swatch-wrapper {
    padding: 0;
}
.color-input::-webkit-color-swatch {
    border: none;
    border-radius: 2px;
}
.table-setting-group:last-child {
    margin-bottom: 0;
}
@media (max-width: 768px) {
    .table-customization-panel {
        width: 100%;
        right: -100%;
    }
    
    .global-table-controls {
        padding: 8px;
    }
    
    .table-setting-row {
        flex-direction: column;
        align-items: stretch;
    }
    
    .table-setting-row label {
        margin-bottom: 4px;
    }
}
.table-controls .icon-btn {
    background: #f5f5f5; /* Light background for the markdown button */
    border-color: #d0d7de;
    min-width: 32px; /* Smaller icon button for table controls */
    height: 32px;
    padding: 6px;
}
.table-controls .icon-btn:hover {
    background: #e0e0e0;
}
table {
    width: 100%;
    table-layout: fixed; /* Ensures column widths are respected */
    border-collapse: collapse;
    font-size: var(--table-font-size, 14px);
    background: #ffffff;
    margin: 0;
}
th, td {
    padding: var(--table-cell-padding, 8px 12px);
    text-align: var(--table-text-align, left);
    border-bottom: var(--table-border-width, 1px) solid var(--table-border-color, #d0d7de);
    white-space: var(--table-text-wrap, normal);
    word-wrap: break-word;
    vertical-align: var(--table-vertical-align, middle);
    box-sizing: border-box;
    overflow: hidden;
    text-overflow: ellipsis;
}
th {
    background: var(--table-header-bg, #f5f5f5) !important;
    color: var(--table-header-color, #000000) !important;
    font-weight: 700;
    text-align: var(--table-text-align, left) !important;
}
tbody tr:hover {
    background: var(--table-row-hover, #f6f8fa) !important;
}

/* Selected row highlighting for parts preview table */
#partsTableBody tr.selected {
    background: #dbeafe !important;
    border-left: 4px solid #3b82f6 !important;
    box-shadow: 0 0 0 1px #3b82f6 inset !important;
    animation: highlightPulse 0.6s ease-out;
}

@keyframes highlightPulse {
    0% {
        background: #60a5fa;
        transform: scale(1.02);
    }
    100% {
        background: #dbeafe;
        transform: scale(1);
    }
}

#partsTableBody tr.selected td {
    font-weight: 600 !important;
    color: #1e40af !important;
}
th:nth-child(n+2):not(#uniquePartTypesTable th:nth-child(5)):not(#uniquePartTypesTable th:nth-child(1)),
#sheetInventoryTable th:nth-child(2), /* Dimensions should be left */
#materialsUsedTable th:nth-child(2) /* Price should be right */
{
    text-align: right;
}
#uniquePartTypesTable th:nth-child(9) {
    text-align: right;
}
#uniquePartTypesTable th:nth-child(1), /* Name */
#uniquePartTypesTable th:nth-child(5), /* Material */
#uniquePartTypesTable th:nth-child(6), /* Grain */
#uniquePartTypesTable th:nth-child(7), /* Edge Banding */
#partsTable th:nth-child(1), /* ID */
#partsTable th:nth-child(2), /* Name */
#partsTable th:nth-child(3), /* Dimensions */
#partsTable th:nth-child(4), /* Material */
#partsTable th:nth-child(5), /* Grain */
#partsTable th:nth-child(6), /* Edge Banding */
#materialsUsedTable th:nth-child(1), /* Material */
#sheetInventoryTable th:nth-child(1), /* Material */
#sheetInventoryTable th:nth-child(2) /* Dimensions (now descriptive string) */
{
    text-align: left;
}
#uniquePartTypesTable th:nth-child(1), #uniquePartTypesTable td:nth-child(1) { /* Name */
    width: 20%;
}
#uniquePartTypesTable th:nth-child(2), #uniquePartTypesTable td:nth-child(2) { /* W */
    width: 9%;
}
#uniquePartTypesTable th:nth-child(3), #uniquePartTypesTable td:nth-child(3) { /* H */
    width: 9%;
}
#uniquePartTypesTable th:nth-child(4), #uniquePartTypesTable td:nth-child(4) { /* Thick */
    width: 9%;
}
#uniquePartTypesTable th:nth-child(5), #uniquePartTypesTable td:nth-child(5) { /* Material */
    width: 15%;
}
#uniquePartTypesTable th:nth-child(6), #uniquePartTypesTable td:nth-child(6) { /* Grain */
    width: 8%; /* Reduced width */
}
#uniquePartTypesTable th:nth-child(7), #uniquePartTypesTable td:nth-child(7) { /* Edge Banding */
    width: 10%;
}
#uniquePartTypesTable th:nth-child(8), #uniquePartTypesTable td:nth-child(8) { /* Qty */
    width: 5%;
}
#uniquePartTypesTable th:nth-child(9), #uniquePartTypesTable td:nth-child(9) { /* Total Area */
    width: 15%; /* Increased width */
}
@media (max-width: 768px) {
    .table-wrapper, .table-with-controls {
        font-size: 12px;
    }
    
    th, td {
        padding: 6px 8px;
    }
    #uniquePartTypesTable th:nth-child(1), #uniquePartTypesTable td:nth-child(1) { width: 18%; }
    #uniquePartTypesTable th:nth-child(2), #uniquePartTypesTable td:nth-child(2) { width: 8%; }
    #uniquePartTypesTable th:nth-child(3), #uniquePartTypesTable td:nth-child(3) { width: 8%; }
    #uniquePartTypesTable th:nth-child(4), #uniquePartTypesTable td:nth-child(4) { width: 8%; }
    #uniquePartTypesTable th:nth-child(5), #uniquePartTypesTable td:nth-child(5) { width: 12%; }
    #uniquePartTypesTable th:nth-child(6), #uniquePartTypesTable td:nth-child(6) { width: 7%; }
    #uniquePartTypesTable th:nth-child(7), #uniquePartTypesTable td:nth-child(7) { width: 9%; }
    #uniquePartTypesTable th:nth-child(8), #uniquePartTypesTable td:nth-child(8) { width: 5%; }
    #uniquePartTypesTable th:nth-child(9), #uniquePartTypesTable td:nth-child(9) { width: 15%; }
}
tbody tr:hover {
    background: #f6f8fa;
}
.container {
    display: flex;
    flex: 1;
    overflow: hidden;
}
.diagrams-container {
    flex: 1;
    min-width: 300px;
    padding: 16px;
    background: #ffffff;
    border-right: 1px solid #d0d7de;
    overflow-y: auto;
    display: flex;
    flex-wrap: wrap;
    align-content: flex-start;
    gap: 16px;
}
.report-container {
    flex: 1;
    min-width: 400px;
    padding: 16px;
    background: #ffffff;
    overflow-y: auto;
    overflow-x: hidden;
    min-width: 0;
    width: 100%; /* Take full width when diagrams are hidden */
}
#resizer {
    width: 8px;
    background: #d0d7de;
    cursor: col-resize;
    user-select: none;
    flex-shrink: 0;
    transition: background 0.2s;
    border-left: 1px solid #d0d7de;
    border-right: 1px solid #d0d7de;
}
#resizer:hover {
    background: #8c959f;
}
#resizer:active {
    background: #656d76;
}
.tree-controls {
    margin: 12px 0;
    display: flex;
    flex-wrap: wrap;
    gap: 8px;
    align-items: center;
}
.tree-search {
    display: flex;
    gap: 8px;
    align-items: center;
    padding: 12px;
    background: #f6f8fa;
    border-radius: 6px;
    border: 1px solid #d0d7de;
    flex-grow: 1; /* Allows it to take available space */
}
.tree-search input {
    flex: 1;
    padding: 6px 10px;
    border: 1px solid #d0d7de;
    border-radius: 4px;
    font-size: 14px;
}
.tree-search button {
    padding: 6px 12px;
    font-size: 14px;
    margin: 0;
}
.parts-card {
    margin-bottom: 16px;
    border: 1px solid #d0d7de;
    border-radius: 6px;
    background: #ffffff;
    position: relative; /* For absolute positioning of markdown button */
}
.parts-card-title {
    background: #f5f5f5;
    padding: 8px 12px;
    font-weight: 900;
    font-size: 14px;
    border-bottom: 1px solid #d0d7de;
    color: #000000;
    display: flex; /* Allow title and button to be on same line */
    justify-content: space-between;
    align-items: center;
}
.parts-card-title .icon-btn {
    background: transparent;
    border: none;
    padding: 4px; /* Smaller padding for inline button */
    min-width: 28px;
    height: 28px;
    /* Ensure icon color is dark on light background */
    color: #24292e; 
}
.parts-card-title .icon-btn:hover {
    background: #e0e0e0;
}
.parts-preview-table th, .parts-preview-table td {
    padding: 6px 8px;
    font-size: 14px;
}
.used-indicator {
    color: #000000;
    font-weight: 800;
    font-size: 12px;
}
.unused-indicator {
    color: #656d76;
    font-size: 12px;
}
.sort-select {
    padding: 6px 8px;
    border: 1px solid #d0d7de;
    border-radius: 4px;
    font-size: 14px;
    background: #ffffff;
    max-width: 120px; /* Constrain width of sort dropdown */
}
.materials-sort-controls, .materials-filter-buttons, .currency-selector {
    display: flex;
    gap: 8px;
    align-items: center;
}
.currency-selector {
    margin-bottom: 12px;
}
.currency-selector label {
    margin-bottom: 0;
    font-weight: 600;
    color: #1a1a1a;
}
.tree-structure {
    background: #ffffff;
    border: 1px solid #d0d7de;
    border-radius: 6px;
    padding: 16px;
    margin: 12px 0;
    max-height: 500px;
    overflow-y: auto;
    font-size: 14px;
}
.modal {
    display: none;
    position: fixed;
    z-index: 1000;
    left: 0;
    top: 0;
    width: 100%;
    height: 100%;
    background: rgba(0,0,0,0.5);
}
.modal-content {
    background: #ffffff;
    margin: 5% auto;
    padding: 20px;
    border: 1px solid #d0d7de;
    width: 520px;
    max-width: 90%;
    border-radius: 6px;
}
.close {
    color: #656d76;
    float: right;
    font-size: 24px;
    font-weight: bold;
    cursor: pointer;
}
.close:hover {
    color: #24292e;
}
.stats-grid {
    display: grid;
    grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
    gap: 16px;
    margin-bottom: 16px;
}
.stat-card {
    background: #f6f8fa;
    padding: 16px;
    border-radius: 6px;
    border: 1px solid #d0d7de;
    text-align: center;
}
.stat-number {
    font-size: 24px;
    font-weight: 900;
    color: #24292e;
    margin-bottom: 4px;
}
.stat-label {
    font-size: 12px;
    color: #656d76;
    font-weight: 600;
}
.preset-selection {
    display: grid;
    grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
    gap: 12px;
    margin-bottom: 16px;
}
.material-option {
    background: #ffffff;
    border: 1px solid #d0d7de;
    border-radius: 6px;
    padding: 12px;
    cursor: pointer;
    transition: all 0.15s;
}
.material-option:hover {
    background: #f6f8fa;
    border-color: #8c959f;
}
.material-option.selected {
    background: #24292e;
    color: #ffffff;
    border-color: #24292e;
}
.material-name {
    font-size: 14px;
    font-weight: 900;
    margin-bottom: 4px;
}
.material-details {
    font-size: 12px;
    color: #656d76;
    margin-bottom: 2px;
}
.material-option.selected .material-details,
.material-option.selected .material-pattern {
    color: #ffffff;
    opacity: 0.8;
}
.material-pattern {
    font-size: 12px;
    color: #656d76;
    font-style: italic;
}
.results-summary {
    display: grid;
    grid-template-columns: 1fr 1fr;
    gap: 24px;
    margin-top: 16px;
}
.result-group {
    background: #f6f8fa;
    padding: 16px;
    border-radius: 6px;
    border: 1px solid #d0d7de;
}
.result-group h3 {
    margin: 0 0 12px 0;
    font-size: 16px;
    font-weight: 900;
    color: #24292e;
}
.result-group p {
    margin: 8px 0;
    font-size: 14px;
    color: #24292e;
}
.result-group strong {
    font-weight: 800;
}
select {
    width: 100%;
    padding: 8px 12px;
    border: 1px solid #d0d7de;
    border-radius: 6px;
    font-size: 14px;
    background: #ffffff;
    color: #24292e;
    box-sizing: border-box;
}
select:focus {
    outline: none;
    border-color: #24292e;
    box-shadow: 0 0 0 3px rgba(36, 41, 46, 0.1);
}
`;
            const diagramsStyleCss = `body {
    font-family: -apple-system, BlinkMacSystemFont, 'Inter', sans-serif;
    margin: 0;
    padding: 0;
    background: #ffffff;
    display: flex;
    flex-direction: column;
    height: 100vh;
    font-size: 14px;
    color: #24292e;
}
.header {
    background: #ffffff;
    border-bottom: 1px solid #d0d7de;
    padding: 12px 20px;
    display: flex;
    justify-content: space-between;
    align-items: center;
    height: 56px;
}
.header h1 {
    font-size: 18px;
    margin: 0;
    font-weight: 600;
    color: #24292e;
}
.developer-credit {
    font-size: 12px;
    margin: 2px 0 0 0;
    color: #656d76;
}
.back-btn, .icon-btn {
    background: #ffffff;
    border: 1px solid #d0d7de;
    padding: 8px 12px;
    border-radius: 6px;
    font-size: 14px;
    color: #24292e;
    cursor: pointer;
    transition: all 0.15s;
}
.back-btn:hover, .icon-btn:hover {
    background: #f6f8fa;
    border-color: #8c959f;
}
.icon-btn {
    display: flex;
    flex-direction: column;
    align-items: center;
    gap: 4px;
    min-width: 60px;
    padding: 8px 10px;
}
.icon-btn .icon {
    font-size: 16px;
}
.icon-btn .label {
    font-size: 11px;
}
button {
    background: #24292e;
    color: white;
    border: none;
    padding: 10px 16px;
    border-radius: 6px;
    font-size: 14px;
    cursor: pointer;
    transition: all 0.15s;
}
button:hover {
    background: #1c2128;
}
.btn-secondary {
    background: #ffffff;
    color: #24292e;
    border: 1px solid #d0d7de;
}
.btn-secondary:hover {
    background: #f6f8fa;
}
.container {
    display: flex;
    flex: 1;
    overflow: visible;
}
.diagrams-container {
    flex: 1 0 auto;
    min-width: 300px;
    padding: 16px;
    background: #ffffff;
    border-right: 1px solid #d0d7de;
    overflow-y: auto;
    overflow-x: hidden;
    display: block;
}
.report-container {
    flex: 1 0 auto;
    min-width: 400px;
    padding: 16px;
    background: #ffffff;
    overflow-y: auto;
    overflow-x: auto;
}
#resizer {
    width: 5px;
    flex-shrink: 0;
    background: #d0d7de;
    cursor: col-resize;
    user-select: none;
    z-index: 10;
}
#resizer:hover {
    background: #24292e;
}
.diagram-card {
    border: 1px solid #d0d7de;
    padding: 16px;
    background: #ffffff;
    border-radius: 8px;
    box-shadow: 0 2px 8px rgba(0,0,0,0.08);
    width: 100%;
    box-sizing: border-box;
    margin-bottom: 20px;
    display: flex;
    flex-direction: column;
    text-align: center;
}

.diagram-header {
    width: 100%;
    margin-bottom: 16px;
}

.diagram-card h3 {
    font-size: 18px;
    margin: 0 0 12px 0;
    font-weight: 600;
    color: #24292e;
}

.diagram-tags {
    display: flex;
    flex-wrap: wrap;
    gap: 8px;
    justify-content: center;
    align-items: center;
}

.diagram-tag {
    display: inline-flex;
    align-items: center;
    gap: 6px;
    padding: 6px 12px;
    border-radius: 6px;
    font-size: 13px;
    font-weight: 500;
    transition: all 0.2s ease;
}

.diagram-tag svg {
    flex-shrink: 0;
}

.material-tag {
    background: #eff6ff;
    color: #1e40af;
    border: 1px solid #bfdbfe;
}

.dimensions-tag {
    background: #f0fdf4;
    color: #15803d;
    border: 1px solid #bbf7d0;
}

.thickness-tag {
    background: #fef3c7;
    color: #92400e;
    border: 1px solid #fde68a;
}

.efficiency-tag {
    background: #f3f4f6;
    color: #374151;
    border: 1px solid #d1d5db;
}

.efficiency-tag.efficiency-high {
    background: #d1fae5;
    color: #065f46;
    border: 1px solid #6ee7b7;
}

.efficiency-tag.efficiency-medium {
    background: #fef3c7;
    color: #92400e;
    border: 1px solid #fde68a;
}

.efficiency-tag.efficiency-low {
    background: #fee2e2;
    color: #991b1b;
    border: 1px solid #fecaca;
}

.diagram-card p {
    font-size: 14px;
    color: #656d76;
    margin: 0 0 12px 0;
}
.diagram-canvas {
    border: 1px solid #d0d7de;
    background: #ffffff;
    border-radius: 4px;
    display: block;
    margin: 0 auto;
}
.table-wrapper {
    overflow-x: auto;
    margin-bottom: 16px;
    border: 1px solid #d0d7de;
    border-radius: 6px;
    box-shadow: 0 2px 4px rgba(0,0,0,0.1);
    width: 850px;
    min-width: 850px;
    padding: 20px;
    box-sizing: border-box;
    position: relative;
}
table {
    border-collapse: collapse;
    font-size: 14px;
    width: 800px;
    min-width: 800px;
    background: #ffffff;
    margin: 0;
    table-layout: auto;
}
th, td {
    padding: 8px 12px;
    text-align: left;
    border-bottom: 1px solid #d0d7de;
    white-space: normal;
    word-wrap: break-word;
    max-width: 300px;
}
th {
    position: sticky;
    top: 0;
    z-index: 10;
    background: #f6f8fa;
    font-weight: 600;
    font-size: 14px;
}
td[title] {
    white-space: normal;
    word-wrap: break-word;
    max-width: 150px;
}
@media (max-width: 768px) {
    .table-wrapper {
        font-size: 12px;
    }
    
    th, td {
        padding: 6px 8px;
        max-width: 120px;
    }
}
tbody tr:hover {
    background: #f6f8fa;
}
.material-item {
    display: inline-flex;
    align-items: center;
    margin: 4px 6px 4px 0;
    padding: 6px 10px;
    background: #f6f8fa;
    border-radius: 4px;
    border: 1px solid #d0d7de;
    font-size: 14px;
}
.material-swatch {
    width: 16px;
    height: 16px;
    border: 1px solid #d0d7de;
    margin-right: 6px;
    border-radius: 3px;
}
.material-name {
    font-size: 14px;
    font-weight: 500;
}
#materialsContainer {
    margin-bottom: 16px;
}
.tabs {
    display: flex;
    gap: 4px;
    background: #f6f8fa;
    padding: 4px;
    border-radius: 6px;
}
.tab-button {
    background: transparent;
    border: none;
    padding: 8px 16px;
    border-radius: 4px;
    font-size: 14px;
    color: #656d76;
    cursor: pointer;
}
.tab-button.active {
    background: #ffffff;
    color: #24292e;
    box-shadow: 0 1px 3px rgba(0,0,0,0.12);
}
.tab-button:disabled {
    opacity: 0.5;
    cursor: not-allowed;
}
.tab-content {
    display: none;
    flex: 1;
    overflow: hidden;
}
.tab-content.active {
    display: flex;
    flex-direction: column;
}
.report-title {
    text-align: center;
    margin-bottom: 24px;
    padding-bottom: 12px;
    border-bottom: 1px solid #d0d7de;
}
.report-title h1 {
    margin: 0;
    font-size: 20px;
    font-weight: 600;
    color: #24292e;
}
.project-value {
    padding: 8px 12px;
    background: #f6f8fa;
    border: 1px solid #d0d7de;
    border-radius: 6px;
    font-size: 14px;
    color: #24292e;
    font-weight: 500;
}
.total-highlight {
    background: #f6ffed !important;
    font-weight: 600;
    color: #22863a;
}
.material-price {
    font-size: 12px;
    color: #656d76;
    margin-left: 8px;
}
.report-header {
    background: #ffffff;
    border-bottom: 1px solid #d0d7de;
    padding: 12px 20px;
    display: flex;
    justify-content: flex-end;
    gap: 12px;
    align-items: center;
}
.icon-export-btn {
    display: flex;
    flex-direction: column;
    align-items: center;
    gap: 4px;
    background: #ffffff;
    border: 1px solid #d0d7de;
    padding: 8px 10px;
    border-radius: 6px;
    font-size: 12px;
    color: #24292e;
    cursor: pointer;
    min-width: 60px;
}
.icon-export-btn:hover {
    background: #f6f8fa;
    border-color: #8c959f;
}
.export-icon {
    width: 16px;
    height: 16px;
}
.export-label {
    font-size: 11px;
    font-weight: 500;
}
.materials-controls-group {
    display: flex;
    flex-direction: column;
    gap: 12px;
    margin-bottom: 16px;
}
.materials-action-buttons, .materials-filter-buttons {
    display: flex;
    gap: 8px;
    flex-wrap: wrap;
}
.material-icon-btn {
    display: flex;
    flex-direction: column;
    align-items: center;
    gap: 4px;
    background: #ffffff;
    border: 1px solid #d0d7de;
    padding: 8px 10px;
    border-radius: 6px;
    font-size: 12px;
    color: #24292e;
    cursor: pointer;
    min-width: 60px;
}
.material-icon-btn:hover {
    background: #f6f8fa;
    border-color: #8c959f;
}
.material-icon {
    width: 16px;
    height: 16px;
}
.materials-sort-controls {
    display: flex;
    gap: 8px;
    align-items: center;
}
.sort-select {
    padding: 6px 8px;
    border: 1px solid #d0d7de;
    border-radius: 4px;
    font-size: 14px;
    background: #ffffff;
}
.tree-controls {
    margin: 12px 0;
}
.tree-search {
    display: flex;
    gap: 8px;
    align-items: center;
    padding: 12px;
    background: #f6f8fa;
    border-radius: 6px;
    border: 1px solid #d0d7de;
}
.tree-search input {
    flex: 1;
    padding: 6px 10px;
    border: 1px solid #d0d7de;
    border-radius: 4px;
    font-size: 14px;
}
.tree-search button {
    padding: 6px 12px;
    font-size: 14px;
    background: #656d76;
    color: white;
    border: none;
    border-radius: 4px;
}
.tree-search button:hover {
    background: #4c5561;
}
.tree-structure {
    background: #ffffff;
    border: 1px solid #d0d7de;
    border-radius: 6px;
    padding: 16px;
    margin: 12px 0;
    max-height: 500px;
    overflow-y: auto;
    font-size: 14px;
}
.tree-header {
    font-weight: 600;
    font-size: 16px;
    color: #24292e;
    margin-bottom: 12px;
    padding-bottom: 6px;
    border-bottom: 1px solid #d0d7de;
}
.tree-node {
    margin: 2px 0;
}
.tree-item {
    padding: 4px 8px;
    border-radius: 4px;
    cursor: pointer;
    display: flex;
    align-items: center;
    gap: 6px;
    font-size: 14px;
}
.tree-expandable:hover {
    background: #f6f8fa;
}
.expand-icon {
    width: 12px;
    text-align: center;
    font-size: 10px;
    color: #656d76;
}
.node-name {
    font-weight: 500;
    color: #24292e;
}
.node-dimensions {
    color: #24292e;
    font-size: 13px;
}
.node-material {
    color: #656d76;
    font-size: 13px;
    font-style: italic;
}
.tree-children {
    border-left: 1px dotted #d0d7de;
    margin-left: 12px;
}
.part-id-btn {
    background: #f6f8fa;
    border: 1px solid #d0d7de;
    padding: 4px 8px;
    border-radius: 4px;
    font-size: 12px;
    color: #24292e;
    cursor: pointer;
    font-weight: 500;
    transition: all 0.15s;
}
.part-id-btn:hover {
    background: #e1e8ed;
    border-color: #8c959f;
    transform: translateY(-1px);
}
.part-label-cell:hover, .part-dimensions-cell:hover {
    background: #f6f8fa !important;
    font-weight: 600;
}
.modal {
    display: none;
    position: fixed;
    z-index: 1000;
    left: 0;
    top: 0;
    width: 100%;
    height: 100%;
    background: rgba(0,0,0,0.5);
    overflow-y: auto;
}
.modal-content {
    background: #ffffff;
    margin: 2vh auto;
    padding: 20px;
    border: 1px solid #d0d7de;
    width: 520px;
    max-width: 90vw;
    max-height: 96vh;
    border-radius: 6px;
    position: relative;
    top: 50%;
    transform: translateY(-50%);
    overflow-y: auto;
}
.close {
    color: #656d76;
    float: right;
    font-size: 24px;
    font-weight: bold;
    cursor: pointer;
}
.close:hover {
    color: #24292e;
}
#modalCanvas {
    border: 1px solid #d0d7de;
    margin: 12px 0;
    border-radius: 4px;
}
#modalInfo {
    text-align: left;
    margin-top: 12px;
}
#modalInfo h3 {
    margin-top: 0;
    font-size: 16px;
    color: #24292e;
}
#modalInfo p {
    margin: 6px 0;
    font-size: 14px;
    color: #656d76;
}
.modal-controls {
    text-align: center;
    margin-bottom: 12px;
}
.modal-controls button {
    margin: 0 6px;
    padding: 8px 12px;
    font-size: 14px;
}
.preview-modal-content {
    width: 85% !important;
    max-width: 900px !important;
    max-height: 85vh !important;
    display: flex !important;
    flex-direction: column !important;
}
.preview-header {
    display: flex;
    justify-content: space-between;
    align-items: center;
    padding-bottom: 12px;
    border-bottom: 1px solid #d0d7de;
    margin-bottom: 12px;
}
.preview-header h2 {
    margin: 0;
    font-size: 18px;
    font-weight: 600;
}
.preview-content {
    flex: 1;
    overflow-y: auto;
    padding: 16px;
    background: #f6f8fa;
    border-radius: 6px;
    margin-bottom: 12px;
}
.preview-footer {
    display: flex;
    gap: 12px;
    justify-content: flex-end;
    padding-top: 12px;
    border-top: 1px solid #d0d7de;
}
.btn-primary {
    background: #22863a;
    color: white;
    border: none;
    padding: 10px 16px;
    border-radius: 6px;
    font-size: 14px;
}
.btn-primary:hover {
    background: #1a6f32;
}
.copy-btn {
    background: transparent;
    border: none;
    padding: 4px;
    margin-left: 8px;
    cursor: pointer;
    border-radius: 4px;
    display: inline-flex;
    align-items: center;
    justify-content: center;
    transition: all 0.15s;
    vertical-align: middle;
}
.copy-btn:hover {
    background: #f6f8fa;
}
.copy-btn svg {
    width: 14px;
    height: 14px;
    stroke: #656d76;
}
.copy-btn:hover svg {
    stroke: #24292e;
}
h2 {
    display: flex;
    align-items: center;
    justify-content: space-between;
    font-size: 18px;
    font-weight: 700;
    color: #24292e;
    margin: 32px 0 16px 0;
    padding: 12px 16px;
    background: #f6f8fa;
    border: 1px solid #d0d7de;
    border-radius: 6px;
    border-left: 4px solid #24292e;
    width: 850px;
    min-width: 850px;
    box-sizing: border-box;
}
.section-separator {
    margin: 24px 0;
    border-bottom: 1px solid #d0d7de;
}
.copy-table-btn {
    background: #f6f8fa;
    border: 1px solid #d0d7de;
    padding: 6px 12px;
    border-radius: 6px;
    cursor: pointer;
    font-size: 12px;
    color: #24292e;
    display: flex;
    align-items: center;
    gap: 6px;
    transition: all 0.2s ease;
    position: relative;
    overflow: hidden;
}
.copy-table-btn:hover {
    background: #e1e8ed;
    border-color: #8c959f;
    transform: translateY(-1px);
    box-shadow: 0 2px 4px rgba(0,0,0,0.1);
}
.copy-table-btn:active {
    transform: translateY(0);
    box-shadow: 0 1px 2px rgba(0,0,0,0.1);
}
.copy-table-btn.copied {
    background: #22863a;
    color: white;
    border-color: #22863a;
}
.copy-table-btn svg {
    width: 14px;
    height: 14px;
    transition: transform 0.2s ease;
}
.copy-table-btn:hover svg {
    transform: scale(1.1);
}
.export-btn {
    display: flex;
    flex-direction: column;
    align-items: center;
    gap: 4px;
    background: #ffffff;
    border: 1px solid #d0d7de;
    padding: 8px 10px;
    border-radius: 6px;
    font-size: 12px;
    color: #24292e;
    cursor: pointer;
    min-width: 60px;
    transition: all 0.15s;
}
.export-btn:hover {
    background: #f6f8fa;
    border-color: #8c959f;
}
.material-actions button {
    background: #ffffff !important;
    border: 1px solid #d0d7de !important;
}
.material-actions button:hover {
    background: #f6f8fa !important;
    border-color: #8c959f !important;
}
.cost-analysis {
    background: #f6f8fa;
    border: 1px solid #d0d7de;
    border-radius: 6px;
    padding: 12px 16px;
    margin: 16px 0 32px 0;
    font-size: 14px;
    color: #656d76;
    border-left: 4px solid #22863a;
}
.cost-breakdown-wrapper {
    display: block !important;
    width: auto !important;
    min-width: auto !important;
    max-width: 600px !important;
    margin: 0 0 32px 0 !important;
    padding: 0 !important;
    border: none !important;
    box-shadow: none !important;
    overflow: visible !important;
    position: static !important;
    float: none !important;
    clear: both !important;
    contain: layout style !important;
    isolation: isolate !important;
}
.cost-breakdown-wrapper,
.cost-breakdown-wrapper *,
.cost-breakdown-wrapper::before,
.cost-breakdown-wrapper::after {
    width: auto !important;
    min-width: auto !important;
    max-width: none !important;
    table-layout: auto !important;
    border-collapse: separate !important;
    position: static !important;
    float: none !important;
    clear: none !important;
    flex: none !important;
    grid-column: auto !important;
    grid-row: auto !important;
    transform: none !important;
}
.table-wrapper .cost-breakdown-wrapper,
table .cost-breakdown-wrapper,
th .cost-breakdown-wrapper,
td .cost-breakdown-wrapper {
    display: block !important;
    width: auto !important;
    min-width: auto !important;
    position: absolute !important;
    left: 0 !important;
    z-index: 1000 !important;
    background: white !important;
    border: 1px solid #ccc !important;
    padding: 10px !important;
}
.cost-breakdown-independent {
    display: block !important;
    padding: 16px !important;
    background: #f6f8fa !important;
    border: 1px solid #d0d7de !important;
    border-radius: 6px !important;
    border-left: 4px solid #22863a !important;
    font-size: 14px !important;
    color: #656d76 !important;
    width: auto !important;
    max-width: 600px !important;
    margin: 0 !important;
    box-sizing: border-box !important;
}
.cost-line-independent {
    display: block !important;
    margin: 6px 0 !important;
    padding: 0 !important;
    line-height: 1.4 !important;
    font-size: 14px !important;
    color: #656d76 !important;
    width: auto !important;
}
.cost-total-independent {
    display: block !important;
    font-weight: bold !important;
    color: #22863a !important;
    margin-top: 12px !important;
    padding-top: 12px !important;
    border-top: 1px solid #d0d7de !important;
    font-size: 16px !important;
    line-height: 1.4 !important;
    width: auto !important;
}
.cost-analysis-isolated {
    display: block !important;
    margin: 0 0 10px 0 !important;
    padding: 8px !important;
    background: #f8f9fa !important;
    border-left: 3px solid #28a745 !important;
    font-size: 12px !important;
    color: #495057 !important;
    width: auto !important;
    max-width: 600px !important;
    position: static !important;
    float: none !important;
    clear: both !important;
    isolation: isolate !important;
}
`;
            
            // Add page break logic for better pagination
            const addPageBreaks = (content) => {
                // Add page breaks before major sections for better layout
                return content
                    .replace('<div class="section">\n        <h2 class="section-title">Cutting Diagrams</h2>', '<div class="section page-break">\n        <h2 class="section-title">Cutting Diagrams</h2>')
                    .replace('<div class="section">\n        <h2 class="section-title">Detailed Parts List</h2>', '<div class="section page-break">\n        <h2 class="section-title">Detailed Parts List</h2>');
            };
            
            let pdfHTML = `<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <title>AutoNestCut Professional Report</title>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600&display=swap" rel="stylesheet">
    <style>${styleCss}</style>
</head>
<body>
    <div class="header">
        <h1>Cut List & Nesting Report</h1>
        <p>Professional Manufacturing Analysis</p>
        <p>Generated: ${timestamp}</p>
    </div>
    
    <div class="floating-controls">
        <button class="floating-btn refresh-btn" onclick="refreshPDFPreview()" title="Refresh">
            <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                <path d="M3 12a9 9 0 0 1 9-9 9.75 9.75 0 0 1 6.74 2.74L21 8"/>
                <path d="M21 3v5h-5"/>
                <path d="M21 12a9 9 0 0 1-9 9 9.75 9.75 0 0 1-6.74-2.74L3 16"/>
                <path d="M3 21v-5h5"/>
            </svg>
        </button>
        <button class="floating-btn export-btn" onclick="window.print()" title="Export PDF">
            <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                <polyline points="6,9 6,2 18,2 18,9"/>
                <path d="M6 18H4a2 2 0 0 1-2-2v-5a2 2 0 0 1 2-2h16a2 2 0 0 1 2 2v5a2 2 0 0 1-2 2h-2"/>
                <polyline points="6,14 6,22 18,22 18,14"/>
            </svg>
        </button>
    </div>

    <div class="section">
        <h2 class="section-title">Project Summary</h2>
        <table>${summaryTable}</table>
    </div>

    <div class="section">
        <h2 class="section-title">Materials Used</h2>
        <table>${costTable}</table>
    </div>

    <div class="section">
        <h2 class="section-title">Unique Part Types</h2>
        <table>${uniquePartsTable}</table>
    </div>

    <div class="section">
        <h2 class="section-title">Sheet Inventory Summary</h2>
        <table>${sheetInventoryTable}</table>
    </div>

    <div class="section page-break large-section">
        <h2 class="section-title">Cutting Diagrams</h2>
        ${generateDiagramsHTML(boardsData)}
    </div>

    <div class="section page-break large-section">
        <h2 class="section-title">Cut Sequences</h2>
        ${cutSequencesHTML}
    </div>

    <div class="section">
        <h2 class="section-title">Usable Offcuts</h2>
        <table>${offcutsTable}</table>
    </div>

    <div class="section page-break large-section">
        <h2 class="section-title">Cut List & Part Details</h2>
        <table>${detailedPartsTable}</table>
    </div>

    <div class="footer">
        <p>AutoNestCut Professional</p>
        <p>Developed by Int. Arch. M.Shkeir</p>
    </div>
</body>
</html>`;

            console.log('Generated PDF HTML length:', pdfHTML.length);
            console.log('Summary table HTML:', summaryTable);
            console.log('Unique parts table HTML:', uniquePartsTable);
            console.log('Cost table HTML:', costTable);
            
            if (typeof callRuby === 'function') {
                // Capture diagram images from canvas elements
                const diagramImages = captureDiagramImages();
                
                // Send JSON with assembly data and diagram images
                const dataToSend = {
                    report: currentReportData?.report || g_reportData || {},
                    diagrams: currentReportData?.diagrams || g_boardsData || [],
                    diagram_images: diagramImages,
                    original_components: currentReportData?.original_components || window.originalComponents || [],
                    hierarchy_tree: currentReportData?.hierarchy_tree || window.hierarchyTree || [],
                    assembly_data: currentReportData?.assembly_data || window.assemblyData || null
                };
                callRuby('print_pdf', JSON.stringify(dataToSend));
            } else {
                // Fallback: open in new window for printing
                const printWindow = window.open('', '_blank');
                printWindow.document.write(pdfHTML);
                printWindow.document.close();
                printWindow.focus();
            }
        }

        function escapeHtml(text) {
            if (typeof text !== 'string') {
                return String(text || '');
            }
            const div = document.createElement('div');
            div.textContent = text;
            return div.innerHTML;
        }
        
        // Helper functions that might be missing
        function formatNumber(value, precision) {
            if (typeof value !== 'number' || isNaN(value) || value === null) {
                return '-';
            }
            const actualPrecision = (precision === 0 || precision === '0' || precision === 0.0) ? 0 : (typeof precision === 'number' ? precision : parseFloat(precision));
            if (isNaN(actualPrecision) || actualPrecision < 0) {
                return value.toFixed(1);
            }
            return value.toFixed(actualPrecision);
        }
        
        function getAreaDisplay(areaMM2) {
            const units = window.currentAreaUnits || 'm2';
            const factor = window.areaFactors[units] || window.areaFactors['m2'];
            const convertedArea = areaMM2 / factor;
            return formatNumber(convertedArea, window.currentPrecision);
        }
        
        function getAreaUnitLabel() {
            const unitMap = {
                'mm2': 'mm²',
                'cm2': 'cm²',
                'm2': 'm²',
                'in2': 'in²',
                'ft2': 'ft²'
            };
            return unitMap[window.currentAreaUnits] || window.currentAreaUnits || 'm²';
        }

        function refreshPDFPreview() {
            showPDFPreview();
        }
        
        function closePDFPreview() {
            const modal = document.getElementById('pdfPreviewModal');
            if (modal) modal.style.display = 'none';
        }
        
        // Setup event listener for PDF content
        window.addEventListener('pdf-ready', function(e) {
            // This is a placeholder for the Ruby integration
            console.log('PDF content ready for export');
        });
    </script>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/html2canvas/1.4.1/html2canvas.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>
    <script src="pdf_export_clean.js"></script>
    
    <script>
        // --- ENHANCED DASHBOARD IMPLEMENTATION ---
        let dashboardCharts = {};
        let currentDashboardFilter = 'all'; // Track current material filter

        function renderDashboard() {
            console.log("Initializing Enhanced Dashboard...");
            const container = document.getElementById('dashboardContent');
            if (!container) return;

            // 1. Check if report data exists
            if (!g_reportData || !g_reportData.summary) {
                container.innerHTML = `
                    <div style="text-align: center; padding: 60px; color: #656d76; background: white; border-radius: 8px; border: 1px solid #d0d7de;">
                        <div style="margin-bottom: 15px; opacity: 0.5;">
                            <svg width="64" height="64" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.5">
                                <rect x="3" y="3" width="18" height="18" rx="2" ry="2"></rect>
                                <line x1="3" y1="9" x2="21" y2="9"></line>
                                <line x1="9" y1="21" x2="9" y2="9"></line>
                            </svg>
                        </div>
                        <h3 style="margin: 0 0 8px 0; color: #24292e;">No Data to Visualize</h3>
                        <p style="margin: 0;">Please go to the <strong>Configuration</strong> tab and generate a cut list first.</p>
                    </div>`;
                return;
            }

            // 2. Prepare Data from the Global Report Object
            const summary = g_reportData.summary;
            const boardTypes = g_reportData.unique_board_types || [];
            const boards = g_reportData.boards || [];
            const currency = summary.currency || '$';
            
            // Apply filter if set
            let filteredBoardTypes = boardTypes;
            let filteredSummary = {...summary};
            
            if (currentDashboardFilter !== 'all') {
                filteredBoardTypes = boardTypes.filter(b => b.material === currentDashboardFilter);
                // Recalculate summary for filtered data
                const filteredBoards = boards.filter(b => b.material === currentDashboardFilter);
                filteredSummary.total_boards = filteredBoards.length;
                filteredSummary.total_project_cost = filteredBoardTypes.reduce((sum, b) => sum + (b.total_cost || 0), 0);
            }
            
            // Prepare Arrays for Charts
            const labels = filteredBoardTypes.map(b => b.material);
            const costs = filteredBoardTypes.map(b => b.total_cost || 0);
            const sheetCounts = filteredBoardTypes.map(b => b.count || 0);
            
            // Calculate parts per material
            const partCounts = g_reportData.unique_part_types ? 
                g_reportData.unique_part_types.reduce((acc, part) => {
                    if (currentDashboardFilter === 'all' || part.material === currentDashboardFilter) {
                        acc[part.material] = (acc[part.material] || 0) + part.total_quantity;
                    }
                    return acc;
                }, {}) : {};
            const partCountData = labels.map(l => partCounts[l] || 0);

            // Calculate waste metrics
            const totalWasteArea = boards.reduce((sum, board) => {
                if (currentDashboardFilter === 'all' || board.material === currentDashboardFilter) {
                    return sum + (board.waste_area || 0);
                }
                return sum;
            }, 0);
            
            const totalUsedArea = boards.reduce((sum, board) => {
                if (currentDashboardFilter === 'all' || board.material === currentDashboardFilter) {
                    return sum + (board.used_area || 0);
                }
                return sum;
            }, 0);
            
            const wastePercentage = totalUsedArea > 0 ? ((totalWasteArea / (totalUsedArea + totalWasteArea)) * 100) : 0;
            const wasteCost = (filteredSummary.total_project_cost * wastePercentage) / 100;
            
            // Calculate carbon footprint (rough estimate: 0.5 kg CO2 per m² of waste)
            const carbonFootprint = (totalWasteArea / 1000000) * 0.5; // Convert mm² to m², then to kg CO2

            // Styling Constants (Matches your App Theme)
            const colors = ['#007cba', '#28a745', '#6f42c1', '#fd7e14', '#e83e8c', '#20c997', '#ffc107', '#17a2b8'];
            const transparentColors = colors.map(c => c + 'CC');
            
            // Build material filter options
            const materialOptions = ['<option value="all">All Materials</option>'];
            boardTypes.forEach(b => {
                materialOptions.push(`<option value="${b.material}" ${currentDashboardFilter === b.material ? 'selected' : ''}>${b.material}</option>`);
            });

            // 3. Inject Dashboard HTML Structure
            container.innerHTML = `
                <style>
                    .dashboard-header { display: flex; justify-content: space-between; align-items: center; margin-bottom: 24px; padding: 20px; background: white; border-radius: 8px; border: 1px solid #d0d7de; }
                    .dashboard-title { font-size: 20px; font-weight: 700; color: #24292e; display: flex; align-items: center; gap: 10px; }
                    .dashboard-controls { display: flex; gap: 12px; align-items: center; }
                    .filter-select { padding: 8px 32px 8px 12px; border: 1px solid #d0d7de; border-radius: 6px; font-size: 14px; background: white; cursor: pointer; }
                    .export-btn { padding: 8px 16px; background: #007cba; color: white; border: none; border-radius: 6px; cursor: pointer; font-size: 14px; display: flex; align-items: center; gap: 6px; transition: background 0.2s; }
                    .export-btn:hover { background: #005a87; }
                    
                    .d-grid { display: grid; grid-template-columns: repeat(auto-fit, minmax(300px, 1fr)); gap: 24px; margin-bottom: 24px; }
                    .d-card { background: white; border: 1px solid #d0d7de; border-radius: 8px; padding: 24px; box-shadow: 0 1px 3px rgba(0,0,0,0.05); transition: transform 0.2s; }
                    .d-card:hover { transform: translateY(-2px); box-shadow: 0 4px 12px rgba(0,0,0,0.1); }
                    .d-card h3 { margin: 0 0 20px 0; font-size: 15px; color: #24292e; border-bottom: 1px solid #eee; padding-bottom: 12px; font-weight: 600; display: flex; align-items: center; gap: 8px; }
                    
                    .kpi-row { display: grid; grid-template-columns: repeat(4, 1fr); gap: 20px; margin-bottom: 30px; }
                    .kpi-card { background: white; padding: 20px; border-radius: 8px; border-left: 4px solid #007cba; box-shadow: 0 2px 5px rgba(0,0,0,0.05); transition: all 0.3s; }
                    .kpi-card:hover { transform: translateY(-2px); box-shadow: 0 4px 12px rgba(0,0,0,0.1); }
                    .kpi-label { font-size: 13px; color: #656d76; font-weight: 600; text-transform: uppercase; letter-spacing: 0.5px; }
                    .kpi-value { font-size: 28px; font-weight: 700; color: #24292e; margin-top: 8px; }
                    .kpi-subtext { font-size: 12px; color: #656d76; margin-top: 4px; }
                    .chart-container { position: relative; height: 300px; width: 100%; }
                    
                    .waste-metric { display: flex; justify-content: space-between; padding: 12px 0; border-bottom: 1px solid #f0f0f0; }
                    .waste-metric:last-child { border-bottom: none; }
                    .waste-label { font-size: 14px; color: #656d76; font-weight: 500; }
                    .waste-value { font-size: 16px; color: #24292e; font-weight: 600; }
                    .waste-value.negative { color: #dc3545; }
                    
                    .gantt-container { overflow-x: auto; }
                    .gantt-row { display: flex; align-items: center; margin-bottom: 8px; }
                    .gantt-label { width: 150px; font-size: 13px; color: #24292e; font-weight: 500; }
                    .gantt-bar-container { flex: 1; height: 30px; background: #f6f8fa; border-radius: 4px; position: relative; }
                    .gantt-bar { height: 100%; background: linear-gradient(90deg, #007cba, #0096e6); border-radius: 4px; display: flex; align-items: center; padding: 0 8px; color: white; font-size: 12px; font-weight: 600; }
                </style>

                <div class="dashboard-header">
                    <div class="dashboard-title">
                        <svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                            <rect x="3" y="3" width="7" height="7"></rect>
                            <rect x="14" y="3" width="7" height="7"></rect>
                            <rect x="14" y="14" width="7" height="7"></rect>
                            <rect x="3" y="14" width="7" height="7"></rect>
                        </svg>
                        Project Dashboard
                    </div>
                    <div class="dashboard-controls">
                        <select class="filter-select" onchange="filterDashboard(this.value)">
                            ${materialOptions.join('')}
                        </select>
                        <button class="export-btn" onclick="exportDashboard()">
                            <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                                <path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"></path>
                                <polyline points="7 10 12 15 17 10"></polyline>
                                <line x1="12" y1="15" x2="12" y2="3"></line>
                            </svg>
                            Export Dashboard
                        </button>
                    </div>
                </div>

                <div class="kpi-row">
                    <div class="kpi-card" style="border-color: #007cba;">
                        <div class="kpi-label">Total Project Cost</div>
                        <div class="kpi-value">${currency}${formatNumber(filteredSummary.total_project_cost, 2)}</div>
                        <div class="kpi-subtext">${filteredSummary.total_boards} sheets used</div>
                    </div>
                    <div class="kpi-card" style="border-color: #28a745;">
                        <div class="kpi-label">Material Efficiency</div>
                        <div class="kpi-value">${formatNumber(summary.overall_efficiency, 1)}%</div>
                        <div class="kpi-subtext">${formatNumber(100 - summary.overall_efficiency, 1)}% waste</div>
                    </div>
                    <div class="kpi-card" style="border-color: #fd7e14;">
                        <div class="kpi-label">Total Waste Cost</div>
                        <div class="kpi-value">${currency}${formatNumber(wasteCost, 2)}</div>
                        <div class="kpi-subtext">${formatNumber(totalWasteArea / 1000000, 2)} m² wasted</div>
                    </div>
                    <div class="kpi-card" style="border-color: #6f42c1;">
                        <div class="kpi-label">Carbon Footprint</div>
                        <div class="kpi-value">${formatNumber(carbonFootprint, 2)} kg</div>
                        <div class="kpi-subtext">CO₂ from waste</div>
                    </div>
                </div>

                <div class="d-grid">
                    <div class="d-card">
                        <h3>
                            <svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                                <path d="M3 3h18v18H3z"></path>
                                <path d="M3 9h18M9 21V9"></path>
                            </svg>
                            Waste Analysis
                        </h3>
                        <div>
                            <div class="waste-metric">
                                <span class="waste-label">Total Waste Area</span>
                                <span class="waste-value negative">${formatNumber(totalWasteArea / 1000000, 2)} m²</span>
                            </div>
                            <div class="waste-metric">
                                <span class="waste-label">Waste Percentage</span>
                                <span class="waste-value negative">${formatNumber(wastePercentage, 1)}%</span>
                            </div>
                            <div class="waste-metric">
                                <span class="waste-label">Waste Cost</span>
                                <span class="waste-value negative">${currency}${formatNumber(wasteCost, 2)}</span>
                            </div>
                            <div class="waste-metric">
                                <span class="waste-label">Used Area</span>
                                <span class="waste-value">${formatNumber(totalUsedArea / 1000000, 2)} m²</span>
                            </div>
                            <div class="waste-metric">
                                <span class="waste-label">Total Sheet Area</span>
                                <span class="waste-value">${formatNumber((totalUsedArea + totalWasteArea) / 1000000, 2)} m²</span>
                            </div>
                        </div>
                    </div>
                    
                    <div class="d-card">
                        <h3>
                            <svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                                <line x1="18" y1="20" x2="18" y2="10"></line>
                                <line x1="12" y1="20" x2="12" y2="4"></line>
                                <line x1="6" y1="20" x2="6" y2="14"></line>
                            </svg>
                            Overall Efficiency vs Waste
                        </h3>
                        <div class="chart-container" style="height: 250px; width: 250px; margin: 0 auto;">
                            <canvas id="efficiencyChart"></canvas>
                        </div>
                    </div>
                </div>

                <div class="d-grid">
                    <div class="d-card">
                        <h3>
                            <svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                                <rect x="3" y="3" width="7" height="7"></rect>
                                <rect x="14" y="3" width="7" height="7"></rect>
                                <rect x="14" y="14" width="7" height="7"></rect>
                                <rect x="3" y="14" width="7" height="7"></rect>
                            </svg>
                            Material Cost Distribution
                        </h3>
                        <div id="costTreemap" style="height: 350px; position: relative;"></div>
                    </div>
                    <div class="d-card">
                        <h3>
                            <svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                                <path d="M21 16V8a2 2 0 0 0-1-1.73l-7-4a2 2 0 0 0-2 0l-7 4A2 2 0 0 0 3 8v8a2 2 0 0 0 1 1.73l7 4a2 2 0 0 0 2 0l7-4A2 2 0 0 0 21 16z"></path>
                                <polyline points="3.27 6.96 12 12.01 20.73 6.96"></polyline>
                                <line x1="12" y1="22.08" x2="12" y2="12"></line>
                            </svg>
                            Sheet Usage by Material
                        </h3>
                        <div class="chart-container" style="height: 350px;">
                            <canvas id="sheetsChart"></canvas>
                        </div>
                    </div>
                </div>

                <div class="d-grid">
                    <div class="d-card">
                        <h3>
                            <svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                                <circle cx="12" cy="12" r="10"></circle>
                                <path d="M12 2a15.3 15.3 0 0 1 4 10 15.3 15.3 0 0 1-4 10 15.3 15.3 0 0 1-4-10 15.3 15.3 0 0 1 4-10z"></path>
                                <path d="M2 12h20"></path>
                            </svg>
                            Part Quantity by Material
                        </h3>
                        <div class="chart-container">
                            <canvas id="partsChart"></canvas>
                        </div>
                    </div>
                    
                    <div class="d-card">
                        <h3>
                            <svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                                <rect x="3" y="4" width="18" height="18" rx="2" ry="2"></rect>
                                <line x1="16" y1="2" x2="16" y2="6"></line>
                                <line x1="8" y1="2" x2="8" y2="6"></line>
                                <line x1="3" y1="10" x2="21" y2="10"></line>
                            </svg>
                            Production Timeline
                        </h3>
                        <div class="gantt-container" id="ganttContainer">
                            ${generateProductionGantt(filteredBoardTypes)}
                        </div>
                    </div>
                </div>
                
                <div class="d-card" style="grid-column: 1 / -1;">
                    <h3>
                        <svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                            <path d="M14.7 6.3a1 1 0 0 0 0 1.4l1.6 1.6a1 1 0 0 0 1.4 0l3.77-3.77a6 6 0 0 1-7.94 7.94l-6.91 6.91a2.12 2.12 0 0 1-3-3l6.91-6.91a6 6 0 0 1 7.94-7.94l-3.76 3.76z"></path>
                        </svg>
                        Cut Sequences Timeline
                    </h3>
                    <div class="gantt-container" id="cutSequencesGantt" style="max-height: 500px; overflow-y: auto;">
                        ${generateCutSequencesGantt(boards)}
                    </div>
                </div>
            `;

            // 4. Render Charts
            renderTreemap('costTreemap', labels, costs, currency, colors);
            
            createChart('efficiencyChart', 'doughnut', ['Efficiency', 'Waste'], 
                [summary.overall_efficiency, 100 - summary.overall_efficiency], 
                'Percentage', ['#28a745', '#dc3545']);
                
            createChart('sheetsChart', 'horizontalBar', labels, sheetCounts, 'Sheets Count', colors);
            
            createChart('partsChart', 'pie', labels, partCountData, 'Parts Count', transparentColors);
        }

        // Generate Production Timeline Gantt Chart
        function generateProductionGantt(boardTypes) {
            if (!boardTypes || boardTypes.length === 0) {
                return '<p style="color: #656d76; text-align: center; padding: 20px;">No production data available</p>';
            }
            
            // Estimate production time: 5 minutes per sheet + 2 minutes per cut
            let html = '';
            let currentTime = 0;
            const maxTime = boardTypes.reduce((sum, b) => sum + (b.count * 7), 0); // Rough estimate
            
            boardTypes.forEach((board, index) => {
                const productionTime = board.count * 7; // 7 minutes per sheet
                const percentage = (productionTime / maxTime) * 100;
                const startPercentage = (currentTime / maxTime) * 100;
                
                html += `
                    <div class="gantt-row">
                        <div class="gantt-label">${board.material}</div>
                        <div class="gantt-bar-container">
                            <div class="gantt-bar" style="width: ${percentage}%; margin-left: ${startPercentage}%;">
                                ${board.count} sheets (~${productionTime} min)
                            </div>
                        </div>
                    </div>
                `;
                
                currentTime += productionTime;
            });
            
            return html;
        }

        // Generate Cut Sequences Gantt Chart - PROPER VERSION
        function generateCutSequencesGantt(boards) {
            if (!boards || boards.length === 0) {
                return '<p style="color: #656d76; text-align: center; padding: 20px;">No cut sequence data available</p>';
            }
            
            const colors = ['#007cba', '#28a745', '#6f42c1', '#fd7e14', '#e83e8c', '#20c997', '#ffc107', '#17a2b8'];
            let html = '';
            
            // Create a separate gantt chart for each board
            boards.forEach((board, boardIndex) => {
                const boardColor = colors[boardIndex % colors.length];
                const materialName = board.material || `Board ${boardIndex + 1}`;
                const partsCount = board.parts_count || 0;
                
                if (partsCount === 0) return;
                
                // Calculate steps for this board
                const totalSteps = 1 + (partsCount * 3); // 1 setup + 3 operations per part
                
                html += `
                    <div style="margin-bottom: 32px; padding: 20px; background: white; border: 1px solid #e1e5e9; border-radius: 8px;">
                        <h4 style="margin: 0 0 16px 0; font-size: 14px; font-weight: 600; color: #24292e; display: flex; align-items: center; gap: 8px;">
                            <div style="width: 12px; height: 12px; background: ${boardColor}; border-radius: 2px;"></div>
                            ${materialName} - ${partsCount} parts
                        </h4>
                        <div style="display: flex; flex-direction: column; gap: 8px;">
                `;
                
                let stepNumber = 0;
                
                // Setup step
                html += `
                    <div style="display: flex; align-items: center; gap: 12px;">
                        <div style="min-width: 40px; text-align: right; font-size: 12px; color: #656d76; font-weight: 600;">
                            ${++stepNumber}
                        </div>
                        <div style="flex: 1; height: 32px; background: ${boardColor}20; border-left: 4px solid ${boardColor}; border-radius: 4px; display: flex; align-items: center; padding: 0 12px; font-size: 13px; font-weight: 500; color: #24292e;">
                            <svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="${boardColor}" stroke-width="2" style="margin-right: 8px;">
                                <rect x="3" y="3" width="18" height="18" rx="2" ry="2"></rect>
                            </svg>
                            Setup Material - Prepare ${board.width}mm × ${board.height}mm sheet
                        </div>
                    </div>
                `;
                
                // Operations for each part
                for (let i = 0; i < partsCount; i++) {
                    const partNum = i + 1;
                    
                    // Cut Length
                    html += `
                        <div style="display: flex; align-items: center; gap: 12px;">
                            <div style="min-width: 40px; text-align: right; font-size: 12px; color: #656d76; font-weight: 600;">
                                ${++stepNumber}
                            </div>
                            <div style="flex: 1; height: 32px; background: ${boardColor}40; border-left: 4px solid ${boardColor}; border-radius: 4px; display: flex; align-items: center; padding: 0 12px; font-size: 13px; color: #24292e;">
                                <svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="${boardColor}" stroke-width="2" style="margin-right: 8px;">
                                    <line x1="5" y1="12" x2="19" y2="12"></line>
                                    <polyline points="12 5 19 12 12 19"></polyline>
                                </svg>
                                Part ${partNum} - Cut Length
                            </div>
                        </div>
                    `;
                    
                    // Cut Width
                    html += `
                        <div style="display: flex; align-items: center; gap: 12px;">
                            <div style="min-width: 40px; text-align: right; font-size: 12px; color: #656d76; font-weight: 600;">
                                ${++stepNumber}
                            </div>
                            <div style="flex: 1; height: 32px; background: ${boardColor}60; border-left: 4px solid ${boardColor}; border-radius: 4px; display: flex; align-items: center; padding: 0 12px; font-size: 13px; color: #24292e;">
                                <svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="${boardColor}" stroke-width="2" style="margin-right: 8px;">
                                    <line x1="12" y1="5" x2="12" y2="19"></line>
                                    <polyline points="5 12 12 19 19 12"></polyline>
                                </svg>
                                Part ${partNum} - Cut Width
                            </div>
                        </div>
                    `;
                    
                    // Edge Banding
                    html += `
                        <div style="display: flex; align-items: center; gap: 12px;">
                            <div style="min-width: 40px; text-align: right; font-size: 12px; color: #656d76; font-weight: 600;">
                                ${++stepNumber}
                            </div>
                            <div style="flex: 1; height: 32px; background: ${boardColor}80; border-left: 4px solid ${boardColor}; border-radius: 4px; display: flex; align-items: center; padding: 0 12px; font-size: 13px; color: #24292e;">
                                <svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="${boardColor}" stroke-width="2" style="margin-right: 8px;">
                                    <rect x="3" y="3" width="18" height="18" rx="2" ry="2"></rect>
                                    <path d="M3 9h18"></path>
                                </svg>
                                Part ${partNum} - Apply Edge Banding
                            </div>
                        </div>
                    `;
                }
                
                html += `
                        </div>
                        <div style="margin-top: 12px; padding-top: 12px; border-top: 1px solid #e1e5e9; font-size: 12px; color: #656d76;">
                            Total Steps: ${totalSteps} | Estimated Time: ~${totalSteps * 2} minutes
                        </div>
                    </div>
                `;
            });
            
            return html || '<p style="color: #656d76; text-align: center; padding: 20px;">No operations to display</p>';
        }

        // Generate Gantt Chart HTML (old function - keeping for compatibility)

        // Generate Gantt Chart HTML (old function - keeping for compatibility)
        function generateGanttChart(boardTypes) {
            if (!boardTypes || boardTypes.length === 0) {
                return '<p style="color: #656d76; text-align: center; padding: 20px;">No production data available</p>';
            }
            
            // Estimate production time: 5 minutes per sheet + 2 minutes per cut
            let html = '';
            let currentTime = 0;
            const maxTime = boardTypes.reduce((sum, b) => sum + (b.count * 7), 0); // Rough estimate
            
            boardTypes.forEach((board, index) => {
                const productionTime = board.count * 7; // 7 minutes per sheet
                const percentage = (productionTime / maxTime) * 100;
                const startPercentage = (currentTime / maxTime) * 100;
                
                html += `
                    <div class="gantt-row">
                        <div class="gantt-label">${board.material}</div>
                        <div class="gantt-bar-container">
                            <div class="gantt-bar" style="width: ${percentage}%; margin-left: ${startPercentage}%;">
                                ${board.count} sheets (~${productionTime} min)
                            </div>
                        </div>
                    </div>
                `;
                
                currentTime += productionTime;
            });
            
            return html;
        }

        // Filter dashboard by material
        function filterDashboard(material) {
            currentDashboardFilter = material;
            renderDashboard();
        }

        // Export dashboard as image
        function exportDashboard() {
            const dashboardContent = document.getElementById('dashboardContent');
            if (!dashboardContent) return;
            
            // Show loading indicator
            const exportBtn = event.target.closest('.export-btn');
            const originalText = exportBtn.innerHTML;
            exportBtn.innerHTML = '<svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" style="animation: spin 1s linear infinite;"><path d="M21 12a9 9 0 1 1-6.219-8.56"></path></svg> Exporting...';
            exportBtn.disabled = true;
            
            // Use html2canvas to capture the dashboard
            html2canvas(dashboardContent, {
                scale: 2,
                backgroundColor: '#f6f8fa',
                logging: false
            }).then(canvas => {
                // Convert to blob and download
                canvas.toBlob(blob => {
                    const url = URL.createObjectURL(blob);
                    const link = document.createElement('a');
                    link.href = url;
                    link.download = `AutoNestCut_Dashboard_${new Date().toISOString().split('T')[0]}.png`;
                    link.click();
                    URL.revokeObjectURL(url);
                    
                    // Restore button
                    exportBtn.innerHTML = originalText;
                    exportBtn.disabled = false;
                });
            }).catch(error => {
                console.error('Export failed:', error);
                alert('Failed to export dashboard. Please try again.');
                exportBtn.innerHTML = originalText;
                exportBtn.disabled = false;
            });
        }

        // Render Treemap for cost distribution
        function renderTreemap(containerId, labels, costs, currency, colors) {
            const container = document.getElementById(containerId);
            if (!container) return;
            
            // Clear container
            container.innerHTML = '';
            
            // Calculate total for percentages
            const total = costs.reduce((sum, cost) => sum + cost, 0);
            if (total === 0) {
                container.innerHTML = '<p style="text-align: center; color: #656d76; padding: 40px;">No cost data available</p>';
                return;
            }
            
            // Create treemap boxes
            let html = '<div style="display: flex; flex-wrap: wrap; height: 100%; gap: 4px;">';
            
            labels.forEach((label, index) => {
                const cost = costs[index];
                const percentage = (cost / total) * 100;
                const color = colors[index % colors.length];
                
                // Calculate box size based on percentage
                const width = Math.sqrt(percentage) * 10; // Proportional sizing
                
                html += `
                    <div style="
                        flex: ${percentage};
                        min-width: ${width}%;
                        background: ${color};
                        padding: 12px;
                        border-radius: 4px;
                        color: white;
                        display: flex;
                        flex-direction: column;
                        justify-content: center;
                        align-items: center;
                        text-align: center;
                        font-size: 13px;
                        font-weight: 600;
                        box-shadow: 0 2px 4px rgba(0,0,0,0.1);
                        transition: transform 0.2s, box-shadow 0.2s;
                        cursor: pointer;
                    " onmouseover="this.style.transform='scale(1.05)'; this.style.boxShadow='0 4px 8px rgba(0,0,0,0.2)';" onmouseout="this.style.transform='scale(1)'; this.style.boxShadow='0 2px 4px rgba(0,0,0,0.1)';">
                        <div style="font-size: 11px; opacity: 0.9; margin-bottom: 4px;">${label.substring(0, 20)}${label.length > 20 ? '...' : ''}</div>
                        <div style="font-size: 18px; font-weight: 700;">${currency}${formatNumber(cost, 0)}</div>
                        <div style="font-size: 11px; opacity: 0.9; margin-top: 4px;">${formatNumber(percentage, 1)}%</div>
                    </div>
                `;
            });
            
            html += '</div>';
            container.innerHTML = html;
        }

        // Render Treemap for cost visualization
        function renderTreemap(containerId, labels, costs, currency, colors) {
            const container = document.getElementById(containerId);
            if (!container) return;
            
            // Calculate total for percentages
            const total = costs.reduce((sum, cost) => sum + cost, 0);
            if (total === 0) {
                container.innerHTML = '<p style="text-align: center; color: #656d76; padding: 40px;">No cost data available</p>';
                return;
            }
            
            // Create treemap data with percentages
            const treemapData = labels.map((label, i) => ({
                label: label,
                cost: costs[i],
                percentage: (costs[i] / total) * 100,
                color: colors[i % colors.length]
            })).sort((a, b) => b.cost - a.cost);
            
            // Simple treemap layout using flexbox
            let html = '<div style="display: flex; flex-wrap: wrap; height: 100%; gap: 4px;">';
            
            treemapData.forEach(item => {
                const width = Math.sqrt(item.percentage) * 10; // Scale for better visual
                const minWidth = Math.max(width, 15); // Minimum width for readability
                
                html += `
                    <div style="
                        flex: ${item.percentage};
                        min-width: ${minWidth}%;
                        background: ${item.color};
                        padding: 12px;
                        border-radius: 6px;
                        display: flex;
                        flex-direction: column;
                        justify-content: center;
                        align-items: center;
                        color: white;
                        font-weight: 600;
                        text-align: center;
                        cursor: pointer;
                        transition: transform 0.2s, box-shadow 0.2s;
                        box-shadow: 0 2px 4px rgba(0,0,0,0.1);
                    " onmouseover="this.style.transform='scale(1.05)'; this.style.boxShadow='0 4px 12px rgba(0,0,0,0.2)';" onmouseout="this.style.transform='scale(1)'; this.style.boxShadow='0 2px 4px rgba(0,0,0,0.1)';">
                        <div style="font-size: 11px; opacity: 0.9; margin-bottom: 4px; overflow: hidden; text-overflow: ellipsis; white-space: nowrap; max-width: 100%;">${item.label.substring(0, 25)}</div>
                        <div style="font-size: 18px; font-weight: 700;">${currency}${formatNumber(item.cost, 0)}</div>
                        <div style="font-size: 12px; opacity: 0.9; margin-top: 2px;">${formatNumber(item.percentage, 1)}%</div>
                    </div>
                `;
            });
            
            html += '</div>';
            container.innerHTML = html;
        }

        // Helper function to create charts cleanly
        function createChart(canvasId, type, labels, data, label, color) {
            const ctx = document.getElementById(canvasId);
            if (!ctx) return;
            
            const context = ctx.getContext('2d');
            
            // Destroy existing chart if it exists (prevents memory leaks/glitches)
            if (dashboardCharts[canvasId]) {
                dashboardCharts[canvasId].destroy();
            }

            // Handle horizontal bar chart
            const isHorizontal = type === 'horizontalBar';
            const chartType = isHorizontal ? 'bar' : type;

            const config = {
                type: chartType,
                data: {
                    labels: labels,
                    datasets: [{
                        label: label,
                        data: data,
                        backgroundColor: Array.isArray(color) ? color : (labels.map((_, i) => {
                            const colors = ['#007cba', '#28a745', '#6f42c1', '#fd7e14', '#e83e8c', '#20c997', '#ffc107', '#17a2b8'];
                            return colors[i % colors.length];
                        })),
                        borderColor: Array.isArray(color) ? '#ffffff' : color,
                        borderWidth: 1
                    }]
                },
                options: {
                    indexAxis: isHorizontal ? 'y' : 'x',
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: {
                        legend: {
                            display: type === 'pie' || type === 'doughnut',
                            position: type === 'pie' || type === 'doughnut' ? 'right' : 'none',
                        }
                    },
                    scales: (type === 'bar' || isHorizontal) ? {
                        y: { 
                            beginAtZero: true, 
                            grid: { color: '#f1f1f1' },
                            ticks: { font: { size: 11 } }
                        },
                        x: { 
                            grid: { display: false },
                            ticks: { font: { size: 11 } }
                        }
                    } : {}
                }
            };

            dashboardCharts[canvasId] = new Chart(context, config);
        }
        
        // Add spin animation for loading indicator
        const style = document.createElement('style');
        style.textContent = `
            @keyframes spin {
                from { transform: rotate(0deg); }
                to { transform: rotate(360deg); }
            }
        `;
        document.head.appendChild(style);
    </script>
</body>
</html>

    
    <!-- Fullscreen Overlay for Parts Table and 3D Viewer -->
    <div id="fullscreenOverlay" class="fullscreen-overlay">
        <div class="fullscreen-header">
            <div class="fullscreen-title" id="fullscreenTitle">Fullscreen View</div>
            <button onclick="exitFullscreen()" class="fullscreen-close-btn" title="Close (ESC)">
                <svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                    <line x1="18" y1="6" x2="6" y2="18"/>
                    <line x1="6" y1="6" x2="18" y2="18"/>
                </svg>
            </button>
        </div>
        <div class="fullscreen-content" id="fullscreenContent">
            <!-- Content will be dynamically inserted here -->
        </div>
    </div>
    
    <script>
        // Fullscreen functionality
        let fullscreenMode = null; // 'table', '3d', or 'both'
        
        function maximizeBothSections() {
            const overlay = document.getElementById('fullscreenOverlay');
            const content = document.getElementById('fullscreenContent');
            const title = document.getElementById('fullscreenTitle');
            
            // Clone the entire wrapper
            const wrapper = document.querySelector('.parts-preview-wrapper');
            const wrapperClone = wrapper.cloneNode(true);
            
            // Remove maximize buttons from clones
            const maxBtns = wrapperClone.querySelectorAll('.maximize-btn');
            maxBtns.forEach(btn => btn.remove());
            
            // Wrap in fullscreen combined wrapper
            content.innerHTML = '';
            const combinedWrapper = document.createElement('div');
            combinedWrapper.className = 'fullscreen-combined-wrapper';
            combinedWrapper.appendChild(wrapperClone);
            content.appendChild(combinedWrapper);
            
            title.textContent = 'Parts Preview & 3D Viewer - Fullscreen';
            overlay.classList.add('active');
            fullscreenMode = 'both';
            
            // Prevent body scroll
            document.body.style.overflow = 'hidden';
            
            // If 3D viewer is active, reinitialize
            setTimeout(() => {
                const canvas = wrapperClone.querySelector('#parts3DCanvas');
                if (canvas && canvas.style.display !== 'none') {
                    if (typeof window.resize3DViewer === 'function') {
                        window.resize3DViewer();
                    }
                }
            }, 100);
        }
        
        /* COMMENTED OUT: maximizePartsTable function - maximize button removed
        function maximizePartsTable() {
            const overlay = document.getElementById('fullscreenOverlay');
            const content = document.getElementById('fullscreenContent');
            const title = document.getElementById('fullscreenTitle');
            
            // Clone the table
            const tableContainer = document.querySelector('.parts-table-container');
            const tableClone = tableContainer.cloneNode(true);
            
            // Remove the maximize button from clone
            const maxBtn = tableClone.querySelector('.maximize-btn');
            if (maxBtn) maxBtn.remove();
            
            // Wrap in fullscreen wrapper
            content.innerHTML = '';
            const wrapper = document.createElement('div');
            wrapper.className = 'fullscreen-table-wrapper';
            wrapper.appendChild(tableClone);
            content.appendChild(wrapper);
            
            title.textContent = 'Parts Preview - Fullscreen';
            overlay.classList.add('active');
            fullscreenMode = 'table';
            
            // Prevent body scroll
            document.body.style.overflow = 'hidden';
        }
        */
        
        function maximize3DViewer() {
            const overlay = document.getElementById('fullscreenOverlay');
            const content = document.getElementById('fullscreenContent');
            const title = document.getElementById('fullscreenTitle');
            
            // Clone the canvas container
            const canvasContainer = document.querySelector('.parts-canvas-container');
            const canvasClone = canvasContainer.cloneNode(true);
            
            // Remove the maximize button from clone
            const maxBtn = canvasClone.querySelector('.maximize-btn');
            if (maxBtn) maxBtn.remove();
            
            // Wrap in fullscreen wrapper
            content.innerHTML = '';
            const wrapper = document.createElement('div');
            wrapper.className = 'fullscreen-canvas-wrapper';
            wrapper.appendChild(canvasClone);
            content.appendChild(wrapper);
            
            title.textContent = '3D Component Viewer - Fullscreen';
            overlay.classList.add('active');
            fullscreenMode = '3d';
            
            // Prevent body scroll
            document.body.style.overflow = 'hidden';
            
            // If 3D viewer is active, we need to reinitialize it in the fullscreen view
            setTimeout(() => {
                const canvas = canvasClone.querySelector('#parts3DCanvas');
                if (canvas && canvas.style.display !== 'none') {
                    // Trigger resize or reinit if needed
                    if (typeof window.resize3DViewer === 'function') {
                        window.resize3DViewer();
                    }
                }
            }, 100);
        }
        
        function exitFullscreen() {
            const overlay = document.getElementById('fullscreenOverlay');
            overlay.classList.remove('active');
            fullscreenMode = null;
            
            // Restore body scroll
            document.body.style.overflow = '';
        }
        
        // ESC key handler
        document.addEventListener('keydown', function(e) {
            if (e.key === 'Escape' && fullscreenMode) {
                exitFullscreen();
            }
        });
        
        // Click outside to close (optional) - but NOT on the close button
        document.getElementById('fullscreenOverlay').addEventListener('click', function(e) {
            // Only close if clicking the overlay itself, not its children
            if (e.target === this) {
                exitFullscreen();
            }
        });
        
        // Make sure close button works by stopping propagation
        document.addEventListener('DOMContentLoaded', function() {
            const closeBtn = document.querySelector('.fullscreen-close-btn');
            if (closeBtn) {
                closeBtn.addEventListener('click', function(e) {
                    e.stopPropagation(); // Prevent event from bubbling
                    exitFullscreen();
                });
            }
        });
    </script>
